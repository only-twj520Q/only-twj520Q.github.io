{"meta":{"title":"twj的个人小站","subtitle":"","description":"博客内容包含前端、JavaScript、随笔、科技等等","author":"twj","url":"https://github.com","root":"/only-twj520Q.github.io/"},"pages":[{"title":"404","date":"2019-11-22T06:54:51.800Z","updated":"2019-11-22T06:54:51.800Z","comments":true,"path":"404/index.html","permalink":"https://github.com/404/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-11-22T07:52:50.644Z","updated":"2019-11-22T07:52:50.644Z","comments":true,"path":"about/index.html","permalink":"https://github.com/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-11-22T07:52:56.502Z","updated":"2019-11-22T07:52:56.502Z","comments":true,"path":"books/index.html","permalink":"https://github.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-22T07:53:00.043Z","updated":"2019-11-22T07:53:00.043Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-11-22T07:53:12.157Z","updated":"2019-11-22T07:53:12.157Z","comments":true,"path":"links/index.html","permalink":"https://github.com/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2019-11-22T07:53:22.952Z","updated":"2019-11-22T07:53:22.952Z","comments":true,"path":"repository/index.html","permalink":"https://github.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-22T07:53:26.720Z","updated":"2019-11-22T07:53:26.720Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"我理解的babel","slug":"我理解的babel","date":"2019-11-08T07:12:55.975Z","updated":"2019-11-22T06:44:24.816Z","comments":true,"path":"2019/11/08/我理解的babel/","link":"","permalink":"https://github.com/2019/11/08/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84babel/","excerpt":"","text":"前言什么是babel？你可以理解它就是一个语法转器，简单来说就是 ES6、ES7等等的新语法转化为ES5或能让低端浏览器正常运行的代码。比如我们经常使用的async、promise语法，在低端浏览器上可能就无法使用，会引起故障，但是只要我们合理使用babel，我们就可以放心大胆地使用新语法。 下面阐述的内容都是基于Babel 7的使用和总结，因babel 6 和babel 7在使用上存在较大差异，所以需要提前说明一下。 核心原理这边简单介绍一下babel的工作原理，其实就是利用了抽象语法树，又称AST。所有的babel插件也是基于AST。 Babel的处理步骤 解析。将源代码变成AST。babel的解析器使用的是babylon。在解析过程中有两个阶段：词法分析和语法分析，词法分析阶段把字符串形式的代码转换为令牌（tokens）流，令牌类似于AST中节点；而语法分析阶段则会把一个令牌流转换成 AST的形式，同时这个阶段会把令牌中的信息转换成AST的表述结构。 转化。操作AST，去改变代码。babel转化器使用的是babel-traverse。babel使用提供的API对AST进行深度优先遍历，在此过程中对节点进行添加、更新及移除操作。 生成。将更改后的AST，再变回代码。babel生成器使用的是babel-generator。将经过转换的AST通过babel-generator再转换成js代码，过程就是深度优先遍历整个AST，然后构建可以表示转换后代码的字符串。 我们编写的代码在编译阶段就被解析成AST，为什么要转化成AST，是因为方便计算机更好地理解代码，方便开发人员更好地操作代码。因为对于计算机或者编辑器而言，代码其实本质上就是字符串。 可以使用这个链接在线测试观察代码生成的AST是什么样的。 123456&#123; \"type\": \"Program\", \"start\": 0, \"end\": 52, \"body\": [...]&#125; 你会发现抽象语法树中不同层级有着相似的结构，这样的结构叫做节点，一个AST是由多个或单个这样的节点组成，节点内部还可以嵌套有多个这样的子节点。 实际使用123456789101112131415161718192021222324252627import * as babylon from 'babylon';import traverse from 'babel-traverse';import generate from 'babel-generator';const code = `function double(x) &#123; return x;&#125;`;const ast = babylon.parse(code);traverse(ast, &#123; enter(path) &#123; if ( path.node.type === \"Identifier\" &amp;&amp; path.node.name === \"x\" ) &#123; path.node.name = \"xx\"; &#125; &#125;&#125;);const output = generate(ast, code);console.log('output', output)// 输出结果&#123; code: \"function double(xx) &#123;↵ return xx;↵&#125;\" map: null rawMappings: null&#125; 基本用法一般而言，babel的使用存在两种方式。 命令行 结合构建工具 通常说来，后者更常见。如果结合webpack使用，我们需要在webpack.config.js中的配置项rules属性中配置babel-loader，然后在项目根目录中新增.babelrc文件，这个文件就是对babel的配置。 webpack.config.js部分配置 12345678910module: &#123; rules: [ &#123; test: /\\.js$/, include: path.resolve('src'), loader: 'babel-loader' &#125;, ... ] &#125; .babelrc部分配置 1234567891011121314&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"targets\": &#123; \"chrome\": \"52\", \"ie\": \"8\" &#125;, \"useBuiltIns\": false, \"corejs\": false &#125; ] ] &#125; babel-loader使用前需要使用npm安装，并且它默认会读取根目录下的.babelrc的配置，或者直接在babel-loader的配置options也是可以的。注意.babelrc文件的内容格式是JSON。 常见名词@babel/corebabel的核心包，它主要的作用就是编译。 @babel/cli只有@babel/core是无法在命令行使用这些功能的，@babel/cli支持你直接在命令行中编译代码。 1./node_modules/.bin/babel src --out-dir lib 上面的命令会编译src目录下的所有js代码，并编译成最终的代码（babel.config.js或者.babelrc配置的），并输出到lib目录下。--out-dir代表输出到哪个目录下。 @babel/nodebabel-node 命令并非独立安装，在babel 7以前，需要通过安装 babel-cli 包获得。而在babel 7以后，babel 的模块被拆分。因此需要安装 @babel/core和 @babel/node 两个包来获取。 1234// 安装npm i -g @babel/core @babel/node// 使用babel-node test.js @babel/polyfillbabel默认只转化js语法，比如对let ，const，class等。它不转换新的API，比如Set、Map、Reflect、Symbol、Promise 等全局对象，包括全局对象上的方法，比如Object.assign。 我们使用babel官网提供的的try out功能做演示。 如图，我们可以看到babel插件默认只会对class，箭头函数这些js语法糖进行转化。但是对新的API它默认不会进行支持，比如上图中的Promise。所以我们可以引入@babel/polyfill。这个库包含了core-js和regenerator-runtime。它是对完整的ES6环境的模拟，我们需要在入口文件或者所有代码的前面引入这个库。 1234import '@babel/polyfill'// 等同于import \"core-js/shim\";import \"regenerator-runtime/runtime\"; 但是这个库有两个很不可忽略的问题。 体积太大。在非压缩的前提下，能达到几百K，而且如果我们只是使用了其中某个特性的情况下，这会造成很大的浪费。 会污染全局变量，因为它会增加很多全局变量API，或者在很多类的原型链上都作了修改，从而实现增加实例方法。如果我们开发的也是一个类库供其他开发者使用，这种情况就会变得非常不可控。 至于说解决方案下面会提到。 核心使用需要记住的是，babel本身不具有任何转化能力，我们把它转化的功能都分解到一个个插件中去。所以，当我们不配置任何插件的时候，输入和输出的代码都是一样的。 在配置文件中，我们主要是由两个配置项，分别是预设preset和插件plugins。 新的babel 7已经使用了新的插件语法。 预设preset先解释一下什么是预设，在没有预设这个概念之前，当我们需要使用箭头函数的时候，我们使用@babel/plugin-transform-arrow-functions插件，它的作用就是将ES6的箭头函数转换成普通函数，但是ES6的语法太多了，如果我们单纯依靠引入一个个依赖的插件就太麻烦，而且容易出错。所以预设的出现就解决了这个问题，它可以理解为插件的组合，比如@babel/preset-es2015是对整个ES6语法的插件集合，还有@babel/preset-es2016等等，不过现在这些类似的这些预设官方也不推荐使用了，推荐使用@babel/preset-env。目前常见的预设有@babel/preset-env，@babel/preset-react，@babel/preset-typescript。 @babel/preset-env（重点）重点介绍@babel/preset-env。这是一个能根据配置的运行环境特点，为代码做相应和必要的编译，同时支持浏览器和node，比如如果你要求的运行环境浏览器版本比较低，转化的代码可能会比较多，如果要求支持的是高版本浏览器，可能你都不需要转化ES6的语法，从而节省了很多空间。如果不写任何配置项，env 等价于 latest，也等价于es2015 + es2016 + es2017 三个相加(不包含 stage-x 中的插件)。env 包含的插件列表维护在这里 1234567891011121314151617181920// 浏览器&#123; \"presets\": [ [\"@babel/preset-env\", &#123; \"targets\": &#123; \"browsers\": [\"last 2 versions\", \"safari &gt;= 7\"] &#125; &#125;] ]&#125;// node&#123; \"presets\": [ [\"@babel/preset-env\", &#123; \"targets\": &#123; \"node\": \"6.10\" &#125; &#125;] ]&#125; 此外babel 7的还有一个重要的变化是删除了stage-x的相关插件，这是一个实验性的语法插件，所有针对处于标准提案阶段的功能所编写的预设（stage preset）都已被弃用。@babel/preset-env将只支持到stage-4。stage 是向下兼容 0&gt;1&gt;2&gt;3&gt;4 所包含的插件数量依次减少。 简单说明一下，TC39 将提案分为以下几个阶段： Stage 0 - 设想（Strawman）：只是一个想法，可能有 Babel插件。 Stage 1 - 建议（Proposal）：这是值得跟进的。 Stage 2 - 草案（Draft）：初始规范。 Stage 3 - 候选（Candidate）：完成规范并在浏览器上初步实现。 Stage 4 - 完成（Finished）：将添加到下一个年度版本发布中。 useBuiltIns配置这是一个preset-env的重要配置选项，它的出现是为了解决上述提到@babel/polyfill的缺陷，它将会自动检测语法帮你require你代码中使用的部分polyfill。 1234567891011&#123; \"presets\": [ [\"@babel/preset-env\", &#123; \"useBuiltIns\": \"usage\", \"corejs\": 2, \"targets\": &#123; \"browsers\": [\"last 2 versions\", \"safari &gt;= 7\"] &#125; &#125;] ]&#125; 这个字段的可选值包括：usage、entry 和 false， 默认为 false，表示不对 polyfills 处理。 usage：它会在你使用到 ES6 新特性时，自动从core-js中添加相关的模块和方法，不会造成全局污染。 entry：需要在入口使用import &quot;@babel/polyfill&quot;，将 polyfill 拆分引入，仅引入有浏览器不支持的 polyfill 如上图，配置了entry以后，import @babel/polyfill会被分拆成很多require(&quot;core-js/modules/xxx&quot;)，它其实会根据@babel/preset-env配置的目标环境将一个大的库分拆引入。事实上，@babel/polyfill这个包本身是没有内容的，它依赖于core-js和regenerator-runtime这两个包，这两个包提供了ES6规范的运行时环境。因此当我们不需要按需polyfill时直接引入@babel-polyfill就行了，它会把core-js和regenerator-runtime全部导入，当我们配置了entry以后，它会根据目标环境自动按需引入core-js和regenerator-runtime。 如上图，当配置了usage以后，我们无需手动import &#39;@babel/polyfill&#39;，它会根据我们的实际代码结合配置的目标环境，自动引入相应的库。 所以，比较这两个配置字段，我更倾向于使用usage这种方式，事实上，它才是真正做到了按需引入。 插件plugin插件的作用是为了实现某个具体功能，比如预设不能支持的，比如@babel/plugin-proposal-decorators是为了解决装饰器的问题，比如@babel/plugin-syntax-dynamic-import是为了解决webpack动态引入某个模块的问题。 @babel/plugin-transform-runtime（重点）这个插件能解决@babel/polyfill提供的类或者实例方法污染全局作用域的情况的。它的作用和上面的useBuiltIns很类似。 @babel/plugin-transform-runtime插件是为了解决 运行时引入，为了解决多个文件重复引用相同helpers 局部引入，为了解决新API方法全局污染 对比上面的两个图，我们用class举例，可以发现，如果使用这个插件，它会在每个模块的内部重复定义这个相同的函数方法，虽然最后的结果也没有问题，但是会造成出现很多重复代码，并且增大了体积。而如果使用了插件以后，我们发现从定义方法改成引用，那重复定义就变成了重复引用，就不存在代码重复的问题了。如上图，可以发现，class这个helper 就是通过 require 引入的，这样就不会存在代码重复的问题了。 在使用 babel-plugin-transform-runtime 的时候必须把 babel-runtime 当做依赖。 babel-runtime内部集成了 core-js：转换一些内置类 (Promise, Symbols等等) 和静态方法 (Array.from 等)。绝大部分转换是这里做的，自动引入。 regenerator：作为 core-js 的拾遗补漏，主要是对 generator/yield 和 async/await 两组的支持。当代码中有使用 generators/async 时自动引入。 helpers： 如上面的 asyncToGenerator 就是其中之一，其他还有如 jsx, classCallCheck 等等，可以查看 babel-helpers。 但是这个插件也有缺点：babel-plugin-transform-runtime 不支持 类的实例方法 (比如数组的filter方法等) 还有一个需要注意的是，我发现默认情况下这个插件不会对ES6新的API进行polyfill，就是说它默认不会转化新的特性比如Promise、Object.assign。所以我们还需要配置corejs这个字段，并安装对应的依赖@babel/runtime-corejs2。 123456789101112131415npm install --save @babel/runtime-corejs2&#123; \"plugins\": [ [ \"@babel/plugin-transform-runtime\", &#123; \"helpers\": true, \"regenerator\": true, \"useESModules\": false, \"corejs\": 2 &#125; ] ] &#125; 注意当plugins 与 presets 同时存在的情况，执行顺序如下 这意味着如果两个转换插件都将处理程序的某个代码片段，则将根据转换插件或 preset 的排列顺序依次执行。 先执行 plugins 的配置项,再执行 Preset 的配置项； plugins 配置项，按照声明顺序执行。 Preset 配置项，按照声明逆序执行。 Babel插件方案对比 方案 优点 缺点 @babel/plugin-transform-runtime 按需引入, 打包体积小 不能兼容实例方法 @babel/polyfill 完整模拟 ES6 环境 打包体积过大, 污染全局对象和内置的对象原型 @babel/preset-env 按需引入, 可配置性高，并且通过配置useBuiltIns实现按需加载@babel/polyfill 暂未发现 结论@babel/plugin-transform-runtime和useBuiltIns配置可以解决替代@babel/polyfill。 babel使用总结综上，我个人对于babel 7的配置方案总结如下 @babel/preset-env + targets + useBuiltins: usage @babel/plugin-transform-runtime 引入必要的plugin","categories":[{"name":"前端","slug":"前端","permalink":"https://github.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"打包构建","slug":"打包构建","permalink":"https://github.com/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/"}]},{"title":"异步错误的获取","slug":"异步错误处理","date":"2019-03-24T05:47:16.101Z","updated":"2019-11-22T06:44:48.615Z","comments":true,"path":"2019/03/24/异步错误处理/","link":"","permalink":"https://github.com/2019/03/24/%E5%BC%82%E6%AD%A5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/","excerpt":"","text":"异步错误的获取JS常见错误当 JavaScript 引擎执行 JavaScript 代码时，会发生各种错误，常见的错误类型有 SyntaxError。SyntaxError是解析代码时发生的语法错误12var 1a; //变量名错误 console.log &apos;hello&apos;); // 缺少括号 ReferenceErrorReferenceError是引用一个不存在的变量时发生的错误。比如在函数中调用一个变量，但是这个变量不存在的时候 TypeErrorTypeError是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。1var obj = &#123;&#125;; obj.handle() //obj.handle is not a function 还有一些这里就不一一介绍了。 try catch使用总之，我们在写代码的时候，程序可能遇到无法预测的异常情况而报错，从而阻塞代码执行，例如，网络连接中断，读取不存在的文件等。上面的错误如果从产生的阶段上来划分的话，可以分成编译阶段和执行阶段的错误。对于执行阶段的错误，我们通常使用try catch来捕获这种错误并处理它。当代码块被try { … }包裹的时候，一旦发生错误，就不再继续执行后续代码，转而跳到catch块。catch (e) { … }包裹的代码就是错误处理代码，变量e表示捕获到的错误。 123456789101112try&#123; console.log(&apos;step1&apos;); var s = null; console.log(s.length) //产生错误 console.log(&apos;step2&apos;);&#125; catch(e)&#123; console.log(&apos;error&apos;);&#125;//outputstep1error 抛出错误程序也可以主动抛出一个错误，让执行流程直接跳转到catch块。抛出错误使用throw语句。实际上，JavaScript允许抛出任意对象，包括数字、字符串。但是，最好还是抛出一个Error对象。 catch捕获JavaScript有一个标准的Error对象表示错误，还有从Error派生的TypeError、ReferenceError等错误对象。我们在处理错误时，可以通过catch(e)捕获的变量e访问错误对象。我们抛出的错误其实是继承在这个Error对象。我们在throw的new Error传的参数就是error实例的message属性。 错误传播如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。 1234567891011try &#123; try&#123; throw new Error(&apos;这是抛出的错误&apos;); &#125; catch(e) &#123; console.log(&apos;内层捕获的错误&apos;); &#125;&#125; catch(e) &#123; console.log(&apos;外层捕获的错误&apos;);&#125;//output内层捕获的错误 finally最后，无论有没有错误，finally一定会被执行。 异步错误如果try模块里面是通过异步操作抛出的异常，异常就不能正常捕获到。比如： 1234567try&#123; setTimeout(()=&gt;&#123; throw new Error(&apos;fail&apos;); &#125;,1000);&#125; catch (e)&#123; console.log(e);&#125; 这是因为异步调用是立即返回的，因此当发生异常的时候，已经脱离了try..catch..的上下文了，所以异常无法被捕获。 异步错误的解决方案异步代码内部直接捕获错误如果是异步的异常，那就在异步代码或者回调函数里捕获异常。 1234567setTimeout(()=&gt;&#123; try&#123; throw new Error(&apos;fail&apos;); &#125;catch (e)&#123; console.log(e); &#125;&#125;,1000); 使用Promise12345678910111213141516171819202122232425262728293031323334353637383940414243var p1 = function()&#123; return new Promise(function(resolve,reject)&#123; throw new Error(&apos;p1_同步_err&apos;); //代码1 setTimeout(()=&gt;&#123; console.log(&apos;p1执行&apos;) resolve(true) // throw new Error(&apos;p1_异步_err&apos;); //代码2 // reject(&apos;p1_rej&apos;) //代码3 &#125;,1000) &#125;)&#125;var p2 = function()&#123; return new Promise(function(resolve,reject)&#123; // throw new Error(&apos;p2_同步_err&apos;); //代码4 setTimeout(()=&gt;&#123; console.log(&apos;p2执行&apos;) // throw new Error(&apos;p2_异步_err&apos;); //代码5 // reject(&apos;p2_rej&apos;) //代码6 &#125;,1000) &#125;)&#125;p1().then(p2).catch(function(err)&#123; console.log(&apos;catch里的错误&apos;) console.log(err)&#125;)//output1catch里的错误a.html:44 Error: p1_同步_err at a.html:23 at new Promise (&lt;anonymous&gt;) at p1 (a.html:22) at a.html:42//output2p1执行a.html:27 Uncaught Error: p1_异步_err at setTimeout (a.html:27)//output3p1执行a.html:43 catch里的错误a.html:44 p1_rej 做了一组试验。六种情况。比如情况1，代码1执行，其它的代码2-6都注释掉。情况2，代码2执行，其它的代码1,3-6都注释掉。情况3，代码3执行，其它的代码1，2，4-6都注释掉。 结论：对于promise而言 如果是同步执行，throw出去的错误可以捕获，而异步执行的不可以 如果是异步执行，throw出去的错误不可以被捕获，只能通过reject来传递。 使用async和await1234567891011121314151617async function doSomething() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; throw new Error(&quot;fail&quot;); &#125;, 1000); &#125;);&#125;async function main() &#123; try &#123; await doSomething(); &#125; catch (e) &#123; console.log(e.message); &#125;&#125;main(); 因为async await实现方式本身也是基于generator+promise 浏览器环境在浏览器中，很多时候出现Error，整个页面就挂掉了。在window对象下有个 onerror 属性。我们可以给window.onerror属性加上一个回调来实现对前端代码的监控。onerror函数会在页面发生js错误时被调用。window.onerror可以拿到出错的信息以及文件名、行号、列号，如果在onerror函数中return true可以让浏览器不输出错误信息到控制台。否则会在控制台中显示错误消息。 nodeJs环境需要说明的是，在node中大多数的异步方法都接受一个 callback 函数，该函数会接受一个 Error 对象传入作为第一个参数。 如果第一个参数不是 null 而是一个 Error 实例，则说明发生了错误，应该进行处理。 12345678const fs = require(&apos;fs&apos;); fs.readFile(&apos;一个不存在的文件&apos;, (err, data) =&gt; &#123; if (err) &#123; console.error(&apos;读取文件出错！&apos;, err); return; &#125; // 否则处理数据 &#125;); uncaughtExceptionuncaughtException 其实是 NodeJS 进程的一个事件。如果进程里产生了一个异常而没有被任何Try Catch捕获会触发这个事件。NodeJS 对于未捕获异常的默认处理是：沿着代码调用路径反向传递回事件循环 - 触发 uncaughtException 事件 - 如果 uncaughtException 没有被监听，那么 - 打印异常的堆栈信息 - 触发进程的 exit 事件。Node.js原生提供uncaughtException事件挂到process对象上，用于捕获所有未处理的异常。 1234567891011121314process.on(&apos;uncaughtException&apos;, function (err) &#123; console.log(&apos;uncaughtException error&apos;);&#125;);try &#123; setTimeout(function()&#123; throw new Error(&apos;fail&apos;); &#125;,1000);&#125; catch (e) &#123; console.log(&quot;catch error&quot;)&#125;//outputuncaughtException error uncaughtException需要注意，如果打算使用 ‘uncaughtException’ 事件作为异常处理的最后补救机制，这是非常粗糙的设计方式。未处理异常本身就意味着应用已经处于了未定义的状态。如果基于这种状态，尝试恢复应用正常进行，可能会造成未知或不可预测的问题。而且uncaughtException错误会导致当前的所有的用户连接都被中断，甚至不能返回一个正常的 HTTP 错误码，这是由于uncaughtException 丢失了当前环境的堆栈，导致 Node 不能正常进行内存回收，比如下面的例子 12345678910app.get(&apos;/&apos;, function (req, res) &#123; setTimeout(function () &#123; throw new Error(&apos;async error&apos;); res.send(200); &#125;, 1000);&#125;);process.on(&apos;uncaughtException&apos;, function (err) &#123; res.send(500); // 做不到，拿不到当前请求的 res 对象&#125;); domain如果可以通过某种方式来捕获回调函数中的异常，那么就不会有uncaughtException 错误导致的崩溃。为了解决这个问题，Node 0.8 之后的版本新增了domain 模块，它可以用来捕获回调函数中抛出的异常。domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即退出。domain 主要的 API 有 domain.run 和 error 事件。通过 domain.run 执行的函数中引发的异常都可以通过 domain 的 error 事件捕获，例如: 123456789101112131415161718var app = express();var server = require(&apos;http&apos;).createServer(app);var domain = require(&apos;domain&apos;);app.use(function (req, res, next) &#123; var reqDomain = domain.create(); reqDomain.on(&apos;error&apos;, function (err) &#123; // 下面抛出的异常在这里被捕获 res.send(500, err.stack); // 成功给用户返回了 500 &#125;); reqDomain.run(next);&#125;);app.get(&apos;/&apos;, function () &#123; setTimeout(function () &#123; throw new Error(&apos;async exception&apos;); // 抛出一个异步异常 &#125;, 1000);&#125;); 上面的代码将 domain 作为一个中间件来使用，保证之后 express 所有的中间件都在domain.run 函数内部执行。这些中间件内的异常都可以通过 error 事件来捕获。我们可以正常的给用户返回 500 错误。 所以，我们可以结合两种异常捕获机制，用 domain 来捕获大部分的异常。对于剩下的异常，通过 uncaughtException 事件来避免服务器直接 crash。","categories":[{"name":"前端","slug":"前端","permalink":"https://github.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/tags/JavaScript/"}]},{"title":"Promise杂谈","slug":"Promise杂谈","date":"2019-03-09T05:34:08.260Z","updated":"2019-11-22T06:45:55.642Z","comments":true,"path":"2019/03/09/Promise杂谈/","link":"","permalink":"https://github.com/2019/03/09/Promise%E6%9D%82%E8%B0%88/","excerpt":"","text":"promise介绍Promise是异步编程的一种解决方案。ES6提供原生支持，并为Promise提供了统一的 API。 从语法上说，Promise是一个JS的原生对象，从它可以获取异步操作的消息。 Promise 本身是一个构造函数，可以像下面这样构造一个Promise实例 1234const p = new Promise((resolve, reject) =&gt; &#123; resolve('success');&#125;);console.log(p); 打印结果如下 Promise实例有两个私有属性，其中[[PromiseStates]] 代表状态，一共有三种状态，[[PromiseValue]]代表结果。 [[PromiseStates]] pending：等待中 resolved：成功 rejected：失败 [[PromiseValue]] 基本介绍就写这么多了，网上资料太多了。 下面主要是对一些特性的试验，基本以代码为主。 特点下面是我自己使用下来总结的一些特点，不具有代表性。 特点一：立即执行性和异步性所谓立即执行性，是指Promise 构造函数新建实例后立即执行，它也是同步代码。 所谓异步性，是指promise 的then()具有异步性，当执行到.then()部分，这部分会自动进入到Promise的异步事件队列，不会阻塞同步代码的执行。需要注意的是promise这种异步任务是属于一个微任务，它和以setTimeout为代表的宏任务在执行顺序上有一点区别。 12345678910const p = new Promise((resolve, reject) =&gt; &#123; console.log('promise内部') resolve('success');&#125;);p.then((value) =&gt; &#123; console.log('then内部', value);&#125;);console.log('主程序'); 输出结果 123promise内部主程序then内部 success 特点二：状态不可逆123456789101112131415161718192021222324252627282930const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('p1 success-1'); resolve('p1 success-2');&#125;);const p2 = new Promise((resolve, reject) =&gt; &#123; resolve('p2 success'); reject('p2 reject');&#125;);const p3 = new Promise((resolve, reject) =&gt; &#123; reject('p3 reject'); resolve('p3 success');&#125;);p1.then((value) =&gt; &#123; console.log(value);&#125;);p2.then((value) =&gt; &#123; console.log(value);&#125;, (err) =&gt; &#123; console.log(err);&#125;);p3.then((value) =&gt; &#123; console.log(value);&#125;, (err) =&gt; &#123; console.log(err);&#125;); 输出结果 123p1 success-1p2 successp3 reject Promise一旦使用了resolve或者reject的时候，状态就不能再次变化，这就是Promise的不可逆性。 特点三：链式调用1234567891011const p = new Promise(((resolve, reject) =&gt; &#123; resolve(5);&#125;));const p1 = p.then((value) =&gt; &#123; console.log(value); return value * 10;&#125;)console.log(p1) 输出结果 ![image-20190313151958689](/Users/apple/Library/Application Support/typora-user-images/image-20190313151958689.png) 可以看到then返回的就是一个Promise，而且是立即返回。这边之所以展开是resolved状态，是因为console.log的异步性，或者说在展开对象属性之前，它保留的是一个对象的引用。如果需要实时查看状态，加个断点即可。 也正是因为then返回的是一个新的Promise，所以可以通过链式调用then 方法。 then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。 then中的返回值大概总结了下面四种情况 return了一个同步的值，经过测试，不管返回null，undefined或者其他类型，then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。 12345678910111213const p = new Promise(((resolve, reject) =&gt; &#123; resolve(1); &#125;));p .then((value) =&gt; &#123; return null; &#125;) .then((value) =&gt; &#123; console.log(value); console.log('对象类型', &#123;&#125;.toString.call(value)); &#125;) 输出结果 null 对象类型 [object Null] &lt;!--￼7--&gt; return了另一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。 比如返回的是Promise.resolved(value)，则Promise的状态为resolved，值为value。 const p1 = new Promise(function (resolve, reject) { resolve(1); }) const p2 = p1.then((value) =&gt; { return p1; }) p2.then((value) =&gt; { console.log(value) }) console.log(p1 === p2) &lt;!--￼8--&gt; throw 一个同步异常，then方法将返回一个Promise，状态是rejected，值是throw的参数。 不常见的例子例子11234567891011121314const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123; console.log('p1-promise'); reject('这个是错误') &#125;, 3000)&#125;);const p2 = new Promise(function (resolve, reject) &#123; console.log('p2-promise'); resolve(p1);&#125;)p2 .then(result =&gt; console.log('then内部', result)) .catch(error =&gt; console.log('catch内部', error)) 输出结果 例子21234567891011121314const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123; console.log('p1-promise'); resolve('这个是错误') &#125;, 3000)&#125;);const p2 = new Promise(function (resolve, reject) &#123; console.log('p2-promise'); reject(p1);&#125;)p2 .then(result =&gt; console.log('then内部', result)) .catch(error =&gt; console.log('catch内部', error)) 输出结果 例子31234567891011121314const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; &#123; console.log('p1-promise'); reject('这个是错误') &#125;, 3000)&#125;);const p2 = new Promise(function (resolve, reject) &#123; console.log('p2-promise'); reject(p1);&#125;)p2 .then(result =&gt; console.log('then内部', result)) .catch(error =&gt; console.log('catch内部', error)) 输出结果 三个例子的结果各异，对于这样的现象，我个人的理解是这样。 p1和p2都是一个Promise。一方面，在p2代码中，如果使用reject方法，p2的状态变成了一个rejected，值就是p1，错误直接被catch住，而且error本身就是p1。三秒以后，如果p1的状态变成了resolved，可以添加then添加回调获取p1的值，p1的状态变成了rejected，则就抛出一个错误了。 另一方面，在p2代码中，如果使用resolve方法，p2的状态不会马上变成resolved，但是这个时候，它会依赖p1的结果，所以它会等到三秒以后p1的状态，如果p1变成了resolved，则会执行then中的代码，如果p1变成了rejected，则会执行catch中的代码，并且很重要的一点是它会对p1进行类似拆箱的操作，会直接拿到p1的结果，作为then或者catch回调的参数。 例子412345678910111213const p1 = Promise.resolve(1);const p2 = Promise.resolve(p1);const p3 = new Promise((resolve, reject) =&gt; &#123; resolve(1);&#125;);const p4 = new Promise((resolve, reject) =&gt; &#123; resolve(p1);&#125;);console.log(p1 === p2);console.log(p1 === p3);console.log(p3 === p4); 输出结果 123truefalsefalse p1接收了一个普通值1，所以会返回一个resolved状态的Promise对象，值为1。p2接收了一个Promise对象p1，会直接返回这个Promise对象。p3和p4通过new方式创建了一个新的Promise对象，所以p3和p1,p4都不会相等。 错误123456789const p = new Promise(((resolve, reject) =&gt; &#123; reject('promise内部的错误');&#125;));p .then((value) =&gt; &#123; console.log(value); return value * 10; &#125;)setTimeout(() =&gt; &#123;console.log('主程序')&#125;, 1000) 如果Promise抛出一个错误，但是在then中没有第二个参数来捕获这个错误的话，就会在控制台打印错误信息，但是不会阻塞代码继续执行。 then中对于错误的处理1234567891011121314151617181920const p = new Promise(((resolve, reject) =&gt; &#123; resolve(1); &#125;));p .then((value) =&gt; &#123; console.log('第一个then的第一个回调', value); return Promise.reject('then中错误啦') &#125;, (value) =&gt; &#123; console.log('第一个then的第二个回调', value); &#125;) .then((value) =&gt; &#123; console.log('第二个then的第一个回调', value); &#125;, (value) =&gt; &#123; console.log('第二个then的第二个回调', value); &#125;) .then((value) =&gt; &#123; console.log('第三个then的第一个回调', value); &#125;, (value) =&gt; &#123; console.log('第三个then的第二个回调', value); &#125;).catch(error =&gt; console.log('catch内部', error)) 输出结果 123第一个then的第一个回调 1第二个then的第二个回调 then中错误啦第三个then的第一个回调 undefined 因为在第二个then的参数中有对错误的处理，所以它可以捕获之前的error信息，并且自身的状态也变成了resolved。所以它能执行第三个then的回调。 如果不在then中进行对之前Promise的捕获，则一旦发生错误，会中断Promise链后面的代码，直接被catch到错误。 123456789101112131415const p = new Promise(((resolve, reject) =&gt; &#123; // throw new Error('promise内部的错误') resolve(1);&#125;));p .then((value) =&gt; &#123; console.log('第一个then的第一个回调', value); return Promise.reject('then中错误啦') &#125;) .then((value) =&gt; &#123; console.log('第二个then的第一个回调', value); &#125;) .then((value) =&gt; &#123; console.log('第三个then的第一个回调', value); &#125;).catch(error =&gt; console.log('catch内部', error)) 输出结果 12第一个then的第一个回调 1catch内部 then中错误啦 throw了一个error如果在Promise中直接throw了一个错误的话，则会让Promise的状态变成rejected，不会直接Promise下面的代码。 12345678const p = new Promise(((resolve, reject) =&gt; &#123; throw new Error('promise内部的错误') resolve(1);&#125;));p .then((value) =&gt; &#123; &#125;) .catch(error =&gt; console.log('catch内部', error)) 输出结果 1234catch内部 Error: promise内部的错误 at Promise ((index):38) at new Promise (&lt;anonymous&gt;) at (index):37 try catch在Promise代码外部使用try catch并不会得到想要的结果。因为try catch捕获的是同步代码中的错误。 关于更多捕获在异步代码中错误的问题，可以参考我的另一篇日记。 顺序执行如何让Promise顺序执行，可以利用async和await。下面是一个很简单的demo。 1234567891011121314let p1 = () =&gt; new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(1), 1000)&#125;)let p2 = () =&gt; new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(2), 2000)&#125;)let p = [p1, p2];async function queue() &#123; for (let i=0; i&lt;p.length; i++)&#123; let result = await p[i](); console.log(result) &#125;&#125;queue() 实际使用简单封装一下ajax 1234567891011121314151617181920212223242526const fetchData = function(url, method, headerConfig) &#123; return new Promise(function(resolve, reject)&#123; const handleChange = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200 || this.status === 304) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const xhr = new XMLHttpRequest(); xhr.open(method, url); xhr.onreadystatechange = handleChange; xhr.responseType = \"json\"; if (typeof headerConfig === 'object' &amp;&amp; headerConfig !== null) &#123; for (let headerKey in headerConfig) &#123; xhr.setRequestHeader(headerKey, headerConfig[headerKey]); &#125; &#125; xhr.send(); &#125;);&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://github.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/tags/JavaScript/"}]},{"title":"canvas和img日常转换操作","slug":"canvas和img日常转换操作","date":"2019-02-12T07:50:28.691Z","updated":"2019-11-22T06:45:20.551Z","comments":true,"path":"2019/02/12/canvas和img日常转换操作/","link":"","permalink":"https://github.com/2019/02/12/canvas%E5%92%8Cimg%E6%97%A5%E5%B8%B8%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C/","excerpt":"","text":"近在做图片上传，接触了一些图片相关的转化操作。主要涉及blob，canvas，dataurl。做一下笔记，以免时间长了忘记。 名词解释Blob Blob对象表示不可变的类似文件对象的原始数据。Blob表示不一定是JavaScript原生形式的数据。File接口基于Blob，继承了blob的功能并将其扩展使其支持用户系统的文件。 摘自MDN 和File对象的区别 File对象就是一个文件，当我们使用input type=&quot;file&quot;标签来上传文件，我们在代码里得到的对象就是一个File对象。 Blob对象就是二进制数据，用来包装二进制文件的容器，可以通过new Blob()创建的对象就是Blob对象。又比如，在XMLHttpRequest里，如果指定responseType为blob，那么得到的返回值也是一个blob对象。 File继承于Blob fileReader fileReader对象允许Web应用程序异步读取存储在计算机上的文件（原始数据缓冲区）的内容，使用File或Blob对象指定要读取的文件或数据。 摘自MDN FileReader是用来读取内存中的文件的API，支持File和Blob两种格式。 转化关系这边从使用场景出发，来整理一下。 file转化为DataURL场景： 获取到一个file类型的图片，直接在页面中预览。如果等图片上传完服务器返回图片的地址，再赋值给img的src属性，无疑浪费了时间和带宽。如果直接在html中预览？这里就是利用html5的新特性，将图片转换为Base64的形式显示出来。 下面的方法可以用于在浏览器上预览本地图片或者视频。 方法1：URL.createObjectURL该方法会根据传入的参数创建一个指向该参数对象的URL，这个URL是一个基于当前文件并且存储在内存中的URL，直到document触发了unload事件或者执行revokeObjectURL来释放。 可以用于在浏览器上预览本地图片或者视频 使用方法如下 1objectURL = URL.createObjectURL(param); 参数：可以为File或者Blob对象 返回：一段带hash的url，类似blob:null/2c5e93e3-f06e-4bf2-8942-1708759bf7a7 注意：在每次调用 createObjectURL()方法时，都会创建一个新的 URL 对象。当不再需要这些 URL 对象时，每个对象必须通过调用URL.revokeObjectURL()方法来释放，让浏览器知道这个URL已经不再需要指向对应的文件。URL.revokeObjectURL()方法会释放一个通过URL.createObjectURL()创建的对象URL。浏览器关闭后自动释放这个对象，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。 代码如下 1234567let img = document.createElement(\"img\");img.src = window.URL.createObjectURL(files[i]);img.width = 200;img.onload = function() &#123; window.URL.revokeObjectURL(this.src);&#125;document.body.appendChild(img); 方法2：FileReader.readAsDataURL该方法会读取指定的 Blob 或 File 对象。读取操作完成的时候，readyState 会变成已完成（DONE），并触发 loadend 事件，同时 result 属性将包含一个data:URL格式的字符串（base64编码）以表示所读取文件的内容。 使用方法如下 1FileReader.readAsDataURL(blob); 参数：可以为File或者Blob对象 返回：图片的base64编码。类似data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIA 代码如下 12345678910let reader = new FileReader();reader.onload = function(e) &#123; // result属性是包含data:URL格式的字符串（base64编码）表示读取的文件内容 img.src = e.target.result; img.onload = function() &#123; dosomething() &#125;&#125;// 读取file对象reader.readAsDataURL(files[i]); 两种方法的区别1、执行时机 createObjectURL是同步执行（立即的） FileReader.readAsDataURL是异步执行 2、内存使用 createObjectURL返回一段带hash的url，并且一直存储在内存中。 FileReader.readAsDataURL则返回包含很多字符的base64，并会比blob url消耗更多内存，但是在不用的时候会自动从内存中清除（通过垃圾回收机制） 3、兼容性 createObjectURL支持从IE10往上的所有现代浏览器 FileReader.readAsDataURL同样支持从IE10往上的所有现代浏览器 从上面答案不难看出，两者的优劣势 使用createObjectURL可以节省性能并更快速，只不过需要在不使用的情况下手动释放内存 如果不太在意设备性能问题，并想获取图片的base64，则推荐使用 canvas 转化为DataURL场景： canvas画出来的图片，需要在其它地方预览或者作为组件之间通信的参数。 使用方法如下 1canvas.toDataURL(type, encoderOptions); 参数： type：图片格式，默认为 image/png encoderOptions：在指定图片格式为 image/jpeg或image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。 返回：图片的base64编码。类似data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIA 使用 当一个内容画到canvas上时，我们可以将它生成任何一个格式支持的图片文件。 这个方法也可以用来对图片进行格式转化。比如，file(png格式) -&gt; canvas -&gt; base64(webp格式)，参考下图。 这个方法还可以用来压缩图片。 canvas 转化为blob场景： canvas画出来的图片，或者利用canvas完成截图功能之后，我们需要把对应的文件上传到服务器。 使用方法如下 1canvas.toBlob(callback, type, encoderOptions); 参数： callback：回调函数，可获得一个单独的Blob对象参数 type：DOMString类型，指定图片格式，默认格式为image/png encoderOptions：Number类型，值在0与1之间，当请求图片格式为image/jpeg或者``image/webp时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略。 返回：无返回值 得到Blob对象以后，可以利用XML2的FormData对象上传，模拟表单控件，异步上传这个二进制文件。 代码如下 1234canvas.toBlob &amp;&amp; canvas.toBlob(function(blob) &#123; let myForm = new FormData(); myForm.append('image', blob); //向表单中添加一个键值对&#125;; DataURL或img转canvas场景： 想要对图片想要进行一些操作，比如加蒙层，修饰，裁剪等等，这些操作可以利用canvas的特性去完成。 使用方法如下 1context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); 参数 image：绘制到上下文的元素。 sx：需要绘制到目标上下文中的，image的矩形（裁剪）选择框的左上角 X 轴坐标。 sy：需要绘制到目标上下文中的，image的矩形（裁剪）选择框的左上角 Y 轴坐标。 swidth：需要绘制到目标上下文中的，image的矩形（裁剪）选择框的宽度。如果不说明，整个矩形（裁剪）从坐标的sx和sy开始，到image的右下角结束。 sheight：需要绘制到目标上下文中的，image的矩形（裁剪）选择框的高度。 代码如下 1234567891011function dataURLToCanvas(dataurl)&#123; let canvas = document.createElement('canvas'); let ctx = canvas.getContext('2d'); let img = new Image(); img.onload = function()&#123; canvas.width = img.width; canvas.height = img.height; ctx.drawImage(img, 0, 0); &#125;; img.src = dataurl;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://github.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/tags/JavaScript/"}]},{"title":"前端性能监控","slug":"前端性能监控","date":"2019-02-12T07:50:28.691Z","updated":"2019-11-22T06:42:54.025Z","comments":true,"path":"2019/02/12/前端性能监控/","link":"","permalink":"https://github.com/2019/02/12/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/","excerpt":"","text":"前言前端性能关系到页面的用户体验，页面的用户体验影响了产品的留存率，而产品则直接决定了一个公司的生死存亡。 Global Web Performance Matters for ecommerce的报告中指出： 57%的用户更在乎网页在3秒内是否完成加载。 52%的在线用户认为网页打开速度影响到他们对网站的忠实度。 每慢1秒造成页面 PV 降低11%，用户满意度也随之降低降低16%。 近半数移动用户因为在10秒内仍未打开页面从而放弃。 在我们做前端性能优化的时候，我们必须知道我们所做的优化到底能提升多少性能，这时候就有必要对前端性能进行监控。当然，我们现在这边讨论的前端性能，是关于页面加载和延迟方面的性能，暂时不讨论对错误处理的相关内容。 Performance首先简单介绍一下前端相关的性能指标，我们关注的几个指标如下。 白屏时间 = 地址栏输入URL回车 - 浏览器出现第一个元素 首屏时间 = 地址栏输入URL回车 - 浏览器第一屏渲染完成 用户可操作时间 页面总下载时间 对开发人员而言，我们常用的性能指标API就是Performance。Performance 接口可以获取到当前页面与性能相关的信息。 我们使用window.performance就可以获得 performance对象。 在控制台我们打印performance，可以看到performance对象包含五个属性。 navigation 提供了在指定的时间段里发生的操作相关信息，包括页面是加载还是刷新、发生了多少次重定向等等。 timing 对象包含延迟相关的性能信息，也是这次我们需要 memory 对象 jsHeapSizeLimit: 内存大小限制 totalJSHeapSize: 可使用的内存 usedJSHeapSize: JS 对象占用的内存 timeOrigin 返回性能测量开始时的时间的高精度时间戳 这些字段的含义与浏览器对应的状态如下 如图，以responseEnd为分界点。图中的红线的左半部分代表网络传输层面，右半部分代表浏览器解析和渲染相关相关。 我这边先给出上述字段的含义，个人认为比较重要的节点加粗了 navigationStart: 表示从上一个文档卸载结束时的 unix 时间戳，如果没有上一个文档，这个值将和 fetchStart 相等。 unloadEventStart: 表示前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0。 unloadEventEnd: 返回前一个页面 unload 时间绑定的回掉函数执行完毕的时间戳。 redirectStart: 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0。 redirectEnd: 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0。 fetchStart: 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前。 domainLookupStart/domainLookupEnd: DNS 域名查询开始/结束的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等 connectStart: HTTP（TCP）开始/重新 建立连接的时间，如果是持久连接，则与 fetchStart 值相等。 connectEnd: HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等。 secureConnectionStart: HTTPS 连接开始的时间，如果不是安全连接，则值为 0。 requestStart: HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存。 responseStart: HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存。 responseEnd: HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存。 domLoading: 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件。 domInteractive: 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件，注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源。 domContentLoadedEventStart: DOM 解析完成后，网页内资源加载开始的时间，在 DOMContentLoaded 事件抛出前发生。 domContentLoadedEventEnd: DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）。 domComplete: DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件。 loadEventStart: load 事件发送给文档，也即 load 回调函数开始执行的时间。 loadEventEnd: load 事件的回调函数执行完毕的时间。 (1) DOMContentLoaded 是指页面元素加载完毕，但是一些资源比如图片还无法看到，但是这个时候页面是可以正常交互的，比如滚动，输入字符等。 jQuery 中经常使用的 $(document).ready() 其实监听的就是 DOMContentLoaded 事件。 (2) load 是指页面上所有的资源（图片，音频，视频等）加载完成。jQuery 中 $(document).load() 监听的是 load 事件。 实战测试由于上面的一些字段解释源于网上的文档和资料，所以我自己需要做一些代码上的测试。 一、 domContentLoadedEventStart 和 domContentLoadedEventEnd 区别代码如下，我们计算了DOMContentLoaded的回调执行时间。 123456window.addEventListener('DOMContentLoaded', () =&gt; &#123; console.time('DOMContentLoaded') for (let i=0;i&lt;1000000000;i++)&#123; &#125; console.timeEnd('DOMContentLoaded')&#125;) 在浏览器控制台，我们打印了这两个字段的差值（时间差）。 结论：两个字段的差值刚好等于DOMContentLoaded的回调执行时间，网上关于字段的解释正确。并且，真正触发DOMContentLoaded事件应该是domContentLoadedEventStart对应的时间。 二、DOMContentLoaded 是对应domContentLoadedEventStart 和 domContentLoadedEventEnd 哪个字段。在浏览器控制台，我们打印了它和navigationStart的差值。 在浏览器network的下面，我们看到显示的DOMContentLoaded时间是1.41秒 结论：浏览器上的DOMContentLoaded的时间实际代表的是domContentLoadedEventEnd 的时间。 ####三、 当前网页load事件还没有发生，返回0。 在DOMContentLoaded事件的回调里，我们发现loadEventStart和loadEventEnd都是0。 在load事件的回调里，我们发现loadEventStart有值，loadEventEnd是0。 结论：如果需要计算load的时间的话，一定要注意代码在页面load事件触发以后再去计算。 性能指标的计算一、白屏时间再明确一下白屏时间的定义，用户从打开页面开始到页面开始有东西呈现为止。 如果是chrome高版本，直接可以通过下面代码获得 12// 白屏时间(chrome.loadTimes().firstPaintTime - chrome.loadTimes().startLoadTime)*1000; 如果是没有该API的普通浏览器 我们通常认为浏览器开始渲染 &lt;body&gt; 或者解析完 &lt;head&gt; 的时间是白屏结束的时间点。 所以，白屏时间 = 开始渲染时间 + 头部资源加载时间 1、开始渲染时间12//开始渲染时间startTime = performance.timing.domLoading - performance.timing.navigationStart; 2、头部资源加载时间我们在&lt;head&gt;的前面计时开始，在&lt;head&gt;最末尾计时结束，中间的差值就是头部资源加载时间。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; &lt;script&gt; var start_time = new Date; //测试时间起点，实际统计起点为 DNS 查询 &lt;/script&gt; &lt;script&gt; for(let i=0; i&lt;10000000000; i++)&#123; &#125; &lt;/script&gt; &lt;!-- 页面 CSS 资源 --&gt; &lt;link rel=\"stylesheet\" href=\"xx.css\"&gt; &lt;script&gt; var end_time = +new Date; //时间终点 var headTime = end_time - start_time; //头部资源加载时间 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 所以最终，白屏时间 = 开始渲染时间(startTime) + 头部资源加载时间(headTime) 二、首屏时间再明确一下首屏时间的定义，用户浏览器首屏内所有内容都呈现出来所花费的时间。 影响首屏的主要因素是图片的加载。基本流程如下 1首屏位置调用 API 开始统计 -&gt; 绑定首屏内所有图片的 load 事件 -&gt; 页面加载完后判断图片是否在首屏内，找出加载最慢的一张 -&gt; 首屏时间 对于网页高度小于屏幕的网站来说，只要在页面底部加上脚本打印当前时间即可；或者对于网页高度大于一屏的网页来说，只要在估算接近于一屏幕的元素的位置后，打印一下当前时间。当然这个时间要得把首屏中所有图片的加载时间也算上。 三、用户可操作时间用户可操作时间影响交互体验，通常我们把所有事件的绑定都放在domReady以后，所以用户可操作的时间可以等于DOM解析完毕的时间。 1用户可操作时间 = performance.timing.domInteractive - performance.timing.navigationStart 四、页面总下载时间页面总下载时间可以统计onload时间，load事件必须等到页面内包括图片的所有元素加载完毕后才能触发。 1页面总下载时间 = performance.timing.loadEventEnd - performance.timing.navigationStart 五、常见的指标1234567891011121314151617181920212223242526// 计算加载时间function getPerformanceTiming() &#123; var t = performance.timing var times = &#123;&#125; // 页面加载完成的时间，用户等待页面可用的时间 times.loadPage = t.loadEventEnd - t.navigationStart // 解析 DOM 树结构的时间 times.domReady = t.domComplete - t.responseEnd // 重定向的时间 times.redirect = t.redirectEnd - t.redirectStart // DNS 查询时间 times.lookupDomain = t.domainLookupEnd - t.domainLookupStart // 读取页面第一个字节的时间 times.ttfb = t.responseStart - t.navigationStart // 资源请求加载完成的时间 times.request = t.responseEnd - t.requestStart // 执行 onload 回调函数的时间 times.loadEvent = t.loadEventEnd - t.loadEventStart // DNS 缓存时间 times.appcache = t.domainLookupStart - t.fetchStart // 卸载页面的时间 times.unloadEvent = t.unloadEventEnd - t.unloadEventStart // TCP 建立连接完成握手的时间 times.connect = t.connectEnd - t.connectStart return times&#125; 性能工具页面性能的评估与监控有很多工具，下面简单介绍几个常用的工具： Page Speed: 谷歌开发的分析和优化网页的工具，可以作为浏览器插件使用 WebPageTest：一款非常优秀的网页前端性能测试工具。使用 WebPagetest，你可以详细掌握网站加载过程中的瀑布流、性能得分、元素分布、视图分析等数据。其中比较直观的视图分析功能可以直接看到页面加载各个阶段的截屏。国内也有利用 WebPagetest 搭建的性能测试平台，推荐使用阿里测。 PhantomJS：自动化监测，模拟Phantom JS 是一个服务器端的 JavaScript API 的 WebKit，基于它可以轻松实现 web 自动化测试。类似的有berserkJS。但是都是服务器模拟测试，不能监控用户真实环境。","categories":[{"name":"前端","slug":"前端","permalink":"https://github.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://github.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"容易混淆的元素位置和大小属性","slug":"容易混淆的元素位置和大小属性","date":"2019-02-12T07:50:28.691Z","updated":"2019-11-22T06:44:02.561Z","comments":true,"path":"2019/02/12/容易混淆的元素位置和大小属性/","link":"","permalink":"https://github.com/2019/02/12/%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%A4%A7%E5%B0%8F%E5%B1%9E%E6%80%A7/","excerpt":"","text":"关于元素的大小关于尺寸的属性 clientHeight和clientWidth： 元素可视内容区域的高度和宽度，不包括水平滚动条、边框和外边距。比如，clientWidth=width+padding 单位是像素px。整数（亲测，这是个四舍五入后的值）。返回值不带px 只读属性 offsetHeight和offsetWidth： 元素可视内容区域的高度和宽度，包括元素的边框、内边距和元素的水平滚动条（如果存在且渲染的话），不包括外边距和:before或:after等伪类元素的高度。比如，offsetWidth=width+padding+borderWidth 单位是像素px。整数（亲测，这是个四舍五入后的值）。返回值不带px 只读属性 scrollHeight 和 scrollWidth： 元素内容的实际高度和宽度，包括由于溢出导致的视图中不可见的内容，也包括:before或:after等伪类元素的高度和宽度，不包括边框和外边距。没有垂直滚动条的情况下，scrollHeight与clientHeight相等。 单位是像素px。整数（亲测，这是个四舍五入后的值）。返回值不带px 只读属性 应用一 获取视口和页面的大小网页大小：一张网页的全部面积，包括不可见的滚动内容，这个大小由代码设置。 浏览器大小：浏览器窗口看到的面积，也叫视口。 1234567891011121314151617181920212223242526272829// 视口大小function getViewport() &#123; if (document.compatMode == 'BackCompat') &#123; // 文档模式判断 return &#123; width: document.body.clientWidth, height: document.body.clientHeight &#125;; &#125; else &#123; return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;; &#125;&#125;// 网页大小function getPagearea() &#123; if (document.compatMode == 'BackCompat') &#123; return &#123; width: document.body.scrollWidth, height: document.body.scrollHeight &#125;; &#125; else &#123; return &#123; width: document.documentElement.scrollWidth, height: document.documentElement.scrollHeight &#125;; &#125;&#125; 二 判断元素是否滚动到底如果元素已经滚动到底，则它的实际内容高度减去已滚动的距离应该等于可视区域高度。下面等式返回true代表已经到底，反之则没有。 1element.scrollHeight - element.scrollTop === element.clientHeight 关于元素的位置关于位置的属性 offsetTop和offsetLeft： 元素距离offsetParent的高度。offsetParent指的是距离该元素最近的position不为static的祖先元素。如果没有则指向body元素。 单位是像素px。整数（亲测，这是个四舍五入后的值）。返回值不带px 只读属性 scrollTop 和 scrollLeft： 元素的滚动距离。比如，scrollTop代表滚动条向下滚动的距离，也是是元素顶部被遮住的距离。在没有滚动条的时候，scrollTop等于0。 单位是像素px。整数（亲测，这是个四舍五入后的值）。返回值不带px 可写属性：如果设置小于0，它的值会等于0。如果设置超过了这个容器可滚动的距离，它的值会等于最大值 应用一 获取元素绝对位置绝对位置，指元素的左上角相对于整张网页左上角的坐标，通过计算获得。每个元素都有 offsetTop 和 offsetLeft 属性，表示该元素的左上角与父容器（offsetParent对象）左上角的距离，因此进行迭代累加，就可以得到该元素的绝对坐标。注意，此方面不适用于 表格 和 iframe，因为在其中，offsetParent 对象未必等于父容器。 123456789function getElementTop(element) &#123; let actualTop = element.offsetTop; let current = element.offsetParent; while (current !== null) &#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; return actualTop;&#125; 注意: 所有这些偏移量属性都是只读的，而且每次访问它们都需要重新计算。因此，应该尽量避免重复访问这些属性；如果需要重复使用其中某些属性的值，可以将它们保存在局部变量中，以提高性能。 样式相关getBoundingClientRect使用方法： 1rectObject = element.getBoundingClientRect(); 返回元素的大小及其相对于视口的位置，返回值是一个对象，包含width, height, bottom, right, left, top, 六个属性。left, right, top, bottom都是元素（不包括margin）相对于视口的原点（视口的上边界和左边界）的距离。 单位是像素px。浮点值。返回值不带px 只读属性，返回浮点值。 如下图，浏览器的支持程度还是非常高的。 自己测试的结果是，这个方法获取的height和offsetHeight大小是一致的。 element.style使用方法： 1inlineStyle = element.style; 返回值是一个CSSStyleDeclaration对象，返回元素标签内的样式，局限性在于使用这个方法只能获取到元素内联样式中的属性值。其中，CSSStyleDeclaration 表示一个CSS属性键值对的集合 单位是像素px。字符串。返回值带px 可写属性 可以这样手动操作单个元素的宽度： 1Element.style.width = '100px'; getComputedStyle使用方法： 1window.getComputedStyle(element, [pseudoElt]); 第二个参数是指定一个要匹配的伪元素的字符串，例如“:before”。如果不需要可以为null。CSS属性值可以使用getPropertyValue(propName)API或直接索引到对象。差别在于getPropertyValue不必使用驼峰的写法。 例如 12window.getComputedStyle(ele, null).getPropertyValue(\"background-color\");window.getComputedStyle(ele, null).backgroundColor; 返回值是一个CSSStyleDeclaration对象，返回一个可以获取当前元素所有最终使用的CSS属性值 单位是像素px。字符串。返回值带px 只读属性 如下图，浏览器的支持程度还是非常高的。 element.currentStyle这个属性是IE浏览器的属性。语法与element.style类似，差别在于element.currentStyle返回的是元素当前应用的最终CSS属性值（包括外链CSS文件，页面中嵌入的&lt;style&gt;属性等）。 应用一 判断元素是否在可视区域123456789101112131415// 方法1function isInViewPortOfTwo (el) &#123; const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight const top = el.getBoundingClientRect() &amp;&amp; el.getBoundingClientRect().top const offsetTop = el.offsetTop const scrollTop = document.documentElement.scrollTop const topGap = offsetTop - scrollTop return topGap &lt;= viewPortHeight&#125;// 方法2function isInViewPortOfTwo (el) &#123; const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; const &#123; top, height &#125; = el.getBoundingClientRect(); return (top &lt;= viewPortHeight) &amp;&amp; (top + height &gt;= 0);&#125; 二 图片懒加载实现一个非常简易的图片懒加载 12345&lt;img class=\"test-img\" src=\"\" data-src=\"httt://www.xxx.com/images/001.jpg\"/&gt; 监听scroll事件，当图片出现在可视区域时，提取data-src的值并赋给src，加载真正图片 123456789101112131415161718192021222324let img = document.getElementsByClassName('test-img');//设置每次遍历的起始图片，防止重复加载let n = 0//首次加载可视区域图片lazyLoad();function lazyLoad() &#123; for (let i = n; i&lt;img.length;i++) &#123; let el = img[i]; if(el.getAttribute('src') === '' &amp;&amp; isInViewPortOfTwo(el))&#123; el.setAttribute('src', el.getAttribute('data-src')) n++; &#125; &#125;&#125;// 判断是否在可视范围内function isInViewPortOfTwo (el) &#123; const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; const top = el.getBoundingClientRect() &amp;&amp; el.getBoundingClientRect().top; return top &lt;= viewPortHeight&#125;window.addEventListener('scroll', _.debounce(lazyLoad, 1000)) 三 获取元素的位置1234567// 相对位置var X= this.getBoundingClientRect().left;var Y =this.getBoundingClientRect().top;// 绝对位置var X= this.getBoundingClientRect().left + document.documentElement.scrollLeft;var Y =this.getBoundingClientRect().top +document.documentElement.scrollTop; 测试代码附上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; #app &#123; border: 1px solid #333333; margin-top: 50px; padding-top: 50px; &#125; #box1 &#123; width: 100px; height: 50px; padding: 50px; border: 50px solid #000000; background-color: #00D8C9; font-size: 20px; overflow: scroll; &#125; #box2 &#123; width: 200px; height: 200px; margin-top: 500px; border: 50px solid #FF4747; background-color: #00D8C9; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div id=\"box1\"&gt;第一个盒子第一个盒子第一个盒子第一个盒子第一个盒子第一个盒子&lt;/div&gt; &lt;div id=\"box2\" style=\"width: 500px; height: 100px\"&gt;第一个盒子&lt;/div&gt; &lt;/div&gt;&lt;script&gt;let box1 = document.getElementById('box1');let box2 = document.getElementById('box2');function getViewport() &#123; // 文档模式判断 if (document.compatMode == 'BackCompat') &#123; return &#123; width: document.body.clientWidth, height: document.body.clientHeight &#125;; &#125; else &#123; return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;; &#125;&#125;function getPagearea() &#123; if (document.compatMode == 'BackCompat') &#123; return &#123; width: document.body.scrollWidth, height: document.body.scrollHeight &#125;; &#125; else &#123; return &#123; width: document.documentElement.scrollWidth, height: document.documentElement.scrollHeight &#125;; &#125;&#125;console.log('视口宽度', getViewport().width)console.log('视口高度', getViewport().height)console.log('网页宽度', getPagearea().width)console.log('网页高度', getPagearea().height)console.log('---------元素尺寸----------')console.log('第一个元素的高度，clientHeight', box1.clientHeight)console.log('第一个元素的高度，offsetHeight', box1.offsetHeight)console.log('第一个元素的高度，scrollHeight', box1.scrollHeight)console.log('第一个元素的高度，scrollTop', box1.scrollTop)console.log('---------元素距离----------')console.log('第二个元素距离父元素的高度 offsetTop', box2.offsetTop)console.log('---------元素样式----------')console.log('第二个元素的DOMRect getBoundingClientRect', box2.getBoundingClientRect())console.log('第二个元素的 style', box2.style)console.log('第二个元素的 getComputedStyle', window.getComputedStyle(box2).getPropertyValue('width'))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考链接 如何判断元素是否进入可视区域viewport","categories":[{"name":"前端","slug":"前端","permalink":"https://github.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/tags/JavaScript/"}]},{"title":"redux源码浅读","slug":"redux源码浅读","date":"2019-02-12T07:50:28.691Z","updated":"2019-11-22T06:46:12.031Z","comments":true,"path":"2019/02/12/redux源码浅读/","link":"","permalink":"https://github.com/2019/02/12/redux%E6%BA%90%E7%A0%81%E6%B5%85%E8%AF%BB/","excerpt":"","text":"redux源码浅读前言Redux是 JavaScript 状态容器，我们通常会在React的项目中搭配这个库用来处理复杂的业务逻辑。 在学习使用Redux一阶段以后，觉得有必要看一下源码，一方面提高对Redux的理解，另一方面也可以通过阅读源码来提高自身的程序设计水平。 Redux基本使用从实际使用出发，我们才能更加容易理解Redux的源码。 下面是Redux的基本使用。 123456789101112131415import &#123; createStore &#125; from 'redux';const store = createStore(reducer, preloadedState, enhancer) // 设置监听函数store.subscribe(listener);// 使用// 首先，用户派发actionstore.dispatch(action);// 然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action。Reducer会返回新的Statelet nextState = reducer(previousState, action);// State一旦有变化，Store就会调用监听函数，监听函数更新state，重新renderfunction listerner() &#123; let newState = store.getState(); component.setState(newState); &#125;listener(); 流程图解在利用Redux进行状态管理时，用户在UI层面触发行为，一个action对象通过store.dispatch派发到Reducer进行触发，接下来Reducer会根据type来更新对应的Store上的状态树，更改后的state会触发对应组件的重新渲染。 如果存在中间件的话，一个action对象在通过store.dispatch派发，在调用reducer函数前，会先经过一个中间件环节。在一个Redux架构中可以用多个中间件，这些中间件一起组织处理请求的“管道”。一个中间件是一个独立的函数，可以组合使用，中间件有一个统一的接口，正因为一个中间件只能完成一个特定的功能，所以把多个中间件组合在一起才能满足比较丰富的应用需求。当然在使用时，也需要按照顺序依次处理传入的action，只有排在前面的中间件完成任务之后，后面的中间件才能有机会继续处理action。 源码简介先开看下 Redux 的源码的目录结构，没错，只有下面几个js，果然是短小精悍，只有2kb，而且生产环境几乎没有什么外部的依赖。虽然结构看起来并不复杂，内容也不是很长，但是Redux 作为函数式编程的典型代表，理解起来并不简单。 我们截取了 github上 的源码，如下图。 所有的js源码文件如下 applyMiddleware.js // Redux的插件机制实现 bindActionCreators.js // 将ActionCreator和dispatch绑定的工具 combineReducers.js // 将store分层的工具 compose.js // 将数个函数合并嵌套执行 createStore.js // 核心，生成store index.js // 入口 源码解析入口文件index.js和bindActionCreators这边就不做介绍了。下面展示的源码部分都是精简版的，去掉了一些注释和无关主逻辑的代码。 createStore首先来看createStore ，它的作用就是创建全局的store对象。在 Redux 中，整个应用只能有一个 Store，全局的state对象就保存在这个全局的store对象中。 语法 参数 reducer 数据类型：函数 参数含义：接受当前state对象和action作为参数，用于处理state逻辑 preloadedState 数据类型：：对象 参数含义：初始的state enhancer： 数据类型：函数 参数含义：store的增强器。这个函数由redux提供的applyMiddleware 函数来进行生成 返回值 store 数据类型：对象 该对象最常用的有三个属性getState，subscribe，dispatch。都是函数类型的 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import $$observable from 'symbol-observable'import ActionTypes from './utils/actionTypes'import isPlainObject from './utils/isPlainObject'export default function createStore(reducer, preloadedState, enhancer) &#123; // 判断 enhancer 是否是函数，enhancer 实际上就是中间件 if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error(...) &#125; return enhancer(createStore)(reducer, preloadedState) &#125; // 判断reducer是否是函数 if (typeof reducer !== 'function') &#123; throw new Error(...) &#125; // 当前reducer let currentReducer = reducer // 当前状态state let currentState = preloadedState // 当前的监听器队列 let currentListeners = [] // 未来的监听器队列 let nextListeners = currentListeners // 是否处于再派发action的状态，即是否在执行reducer函数。这是为了避免死循环。默认为false。 let isDispatching = false // 这个函数用于确保currentListeners 和 nextListeners 是不同的引用 function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; // 返回当前的state function getState() &#123; if (isDispatching) &#123; throw new Error(...) &#125; return currentState &#125; // 订阅监听函数 function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error(...) &#125; if (isDispatching) &#123; throw new Error(...) &#125; let isSubscribed = true // 这里Redux维护了两个队列，currentListeners和nextListeners // 考虑到只存在 currentListeners 的情况，如果我在执行某个 listener 中再次执行 subscribe或者 unsubscribe，会导致索引出错 // 只有当下一次dispatch前，nextListeners又被同步给了currentListeners，之前的注册注销才会生效 ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; if (isDispatching) &#123; throw new Error(...) &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; // 派发action function dispatch(action) &#123; // action必须是一个对象 if (!isPlainObject(action)) &#123; throw new Error(...) &#125; // type必须要有属性，不能是undefined if (typeof action.type === 'undefined') &#123; throw new Error(...) &#125; // 禁止在reducers中进行dispatch，因为这样做可能导致分发死循环 if (isDispatching) &#123; throw new Error(...) &#125; try &#123; isDispatching = true // 将当前的状态和action传给当前的reducer，用于生成最新的state currentState = currentReducer(currentState, action) &#125; finally &#123; // 派发完毕 isDispatching = false &#125; const listeners = (currentListeners = nextListeners) // 在得到新的状态后，依次调用每个监听器函数 for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; 总结createStore就是封装了一些api，通过闭包的形式，保存了两个重要的私有变量，state和listener。 getState：用来获取store中的state的。因为redux是不允许用户直接操作state，对于state的获取，是得通过getState的api来获取store内部的state。 subscribe：可以给 store 的状态添加订阅监听，一旦我们调用了 dispatch 来分发 action ，所有的监听函数就会执行。实际使用中用的不多，是因为react-redux 隐式的为我们帮我们完成了这方面的工作。 dispatch：是redux中一个非常核心的方法，也是我们在日常开发中最常用的方法之一。dispatch函数是用来触发状态改变的，它接受一个 action 对象作为参数，然后 reducer 就可以根据 action 的属性以及当前 store 的状态，来生成一个新的状态，从而改变 store 的状态； composecompose 可以接受一组函数作为参数，从右到左来组合多个函数，然后返回一个组合函数。其实就是函数的合并，它想要实现的效果就像下面这样。 1compose(a, b, c) === (...args) =&gt; a(b(c(...args))) 语法 参数 funcs： 数据类型：函数 参数含义：若干个用于组合的函数 返回值 func： 数据类型：函数 参数含义：执行该函数返回多个函数连续执行的结果 源码123456789export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; underscore 的 compose 函数的实现，可以对比一下 12345678910function compose() &#123; var args = arguments; var start = args.length - 1; return function() &#123; var i = start; var result = args[start].apply(this, arguments); while (i--) result = args[i].call(this, result); return result; &#125;;&#125;; 总结compose函数理解并不困难，就是将多个函数依次进行组合，将后者的返回结果作为前者的参数。很多js库也都有类似的函数实现，redux利用了数组reduce方法的特性巧妙得用一行代码实现了功能。 ###applyMiddleware Redux 中最难的还是applyMiddleware的理解。这个插件机制是Redux一个很重要的功能，使得我们可以很方便的对action做各种各样的操作。比如日志打印，异步数据获取等等，只要添加一个middleware，就可以实现。这个类似于Express或者Koa中的中间件机制。 你可以这样理解函数柯里化，通过闭包保存了外部的一个变量，然后返回一个接收参数的函数，在该函数中使用了保存的变量，然后再返回值。 分析applyMiddleware的代码结构。 是个三级柯里化的高阶函数。它将依次获得三个参数：第一个是 middlewares 数组，第二个是 Redux 原生的 createStore，最后一个是 reducer。 语法 参数 middlewares 数据类型：函数 参数含义：若干个中间件函数 返回值 func 数据类型：函数 参数含义：高阶函数，并作为函数creatStore的参数之一，连续执行该函数可以得到最终的store对象 源码1234567891011121314151617181920212223242526272829303132// 一个最简单的中间件// 所有的中间件都必须遵循这样的格式，这个是因为applyMiddleware函数决定的(&#123;getState, dispatch&#125;) =&gt; next =&gt; action =&gt; next(action);export default function applyMiddleware(...middlewares) &#123; return createStore =&gt; (...args) =&gt; &#123; // 利用传入的createStore和reducer创建一个store const store = createStore(...args) // 这个dispatch并不是最后在中间件里 let dispatch = () =&gt; &#123; throw new Error(...) &#125; // 传给中间件第一层函数的参数 const middlewareAPI = &#123; getState: store.getState, dispatch: (...args) =&gt; dispatch(...args) &#125; // 让每个 middleware 执行一遍，并传入两个参数getState和dispatch const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) // 上面提到compose的作用就是组合函数，结合中间件函数的格式，举个例子 // 如果存在三个中间件a,b,c。在通过上面的函数执行过后，每个中间件返回的是next =&gt; action =&gt; &#123;&#125;这样的函数。函数的参数都是next函数，再返回一个函数，并通过闭包的形式把next函数保存起来。 // 执行compose(...chain)(store.dispatch) // c最先执行，参数是store.dispatch，执行返回action=&gt;&#123;dosomethingC();return dispatch(action)&#125; // b接着执行，参数是c的返回结果，然后返回action=&gt;&#123;dosomethingB();dosomethingA();return dispatch(action)&#125; // a接着执行，参数是b的返回结果，然后返回action=&gt;&#123;dosomethingA();dosomethingB();dosomethingC();return dispatch(action)&#125;，并且赋值给变量dispatch dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; 中间件的执行顺序还有特别重要的就是关于中间件的执行顺序。下面是一个测试的demo。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function middleware1(&#123;dispatch,getState&#125;) &#123; return function(next) &#123; console.log('middleware1 next层',next); return function(action) &#123; console.log('middleware1 action层 开始') next(action) console.log('middleware1 action层 结束') &#125; &#125;&#125;function middleware2(&#123;dispatch,getState&#125;) &#123; return function(next) &#123; console.log('middleware2 next层',next); return function(action) &#123; console.log('middleware2 action层 开始') next(action) console.log('middleware2 action层 结束') &#125; &#125;&#125;function middleware3(&#123;dispatch,getState&#125;) &#123; return function(next) &#123; console.log('middleware3 next层',next); return function(action) &#123; console.log('middleware3 action层 开始') next(action) console.log('middleware3 action层 结束') &#125; &#125;&#125;let noop = ()=&gt;&#123;&#125;// 执行第一层函数const chain = [middleware1, middleware2, middleware3].map(middleware =&gt; middleware(&#123;noop,noop&#125;))// 执行第二层函数let dispatch = compose(...chain)(noop)// 结果如下 /** middleware3 next层 ()=&gt;&#123;&#125; middleware2 next层 ƒ (action) &#123; console.log('middleware3 action层 开始') next(action) console.log('middleware3 action层 结束') &#125; middleware1 next层 ƒ (action) &#123; console.log('middleware2 action层 开始') next(action) console.log('middleware2 action层 结束') &#125;**/// 执行第三层函数dispatch()// 结果如下 /** middleware1 action层 开始 middleware2 action层 开始 middleware3 action层 开始 middleware3 action层 结束 middleware2 action层 结束 middleware1 action层 结束**/ 总结中间件链的最内环是接受store.dispatch作为参数，最后返回的dispatch是增强的dispatch。每个中间件的next也是一次封装增强后的dispath。 combineReducers这个函数是用来整合多个reducers的， 因为createStore只接受一个reducer作为参数。 语法 参数 reducer 数据类型：对象 参数含义：属性值是所有的reducer函数 返回值 finalreducer： 数据类型：函数 参数含义：reducer合并返回最终的reducer函数 源码12345678910111213141516171819202122232425262728293031323334353637383940export default function combineReducers(reducers) &#123; // 获取该对象的 key 值 const reducerKeys = Object.keys(reducers) // 有效的reducer列表 const finalReducers = &#123;&#125; // 过滤无效的reducer for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i] if (process.env.NODE_ENV !== 'production') &#123; if (typeof reducers[key] === 'undefined') &#123; warning(`No reducer provided for key \"$&#123;key&#125;\"`) &#125; &#125; if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125; // 拿到过滤后的reducers的key值 const finalReducerKeys = Object.keys(finalReducers) // 返回最终生成的reducer return function combination(state = &#123;&#125;, action) &#123; // 定义state是否改变，默认false let hasChanged = false // 定义新的nextState const nextState = &#123;&#125; // 遍历reducers对象中的有效key，执行该key对应的value函数，即子reducer函数，并得到对应的state对象,将新的子state挂到新的nextState对象上 for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123; const key = finalReducerKeys[i] const reducer = finalReducers[key] // state树下的key是与 finalReducers下的key相同的 const previousStateForKey = state[key] const nextStateForKey = reducer(previousStateForKey, action) nextState[key] = nextStateForKey // 如果存在触发某个reducer函数返回的state发生了改变，hasChanged置为true hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; // 遍历一遍看是否发生改变，发生改变了返回新的state，否则返回原先的state return hasChanged ? nextState : state &#125;&#125; 总结这个combineReducers函数分为两部分，第一部分是检验传入的reducers的准确性，得到一个过滤后的对象 finalReducers。第二部分就是计算state，根据传入的action，遍历finalReducers，执行每个对象中的每个reducer函数，并将最终的state返回。注意的是，在reducer的代码处理逻辑中，如果没有返回一个新的state独享，而是在原有的state对象上增加或删除某个属性并返回。在比较新旧state的时候，会认为两个对象是一样的，最终不会 总结Redux设计巧妙，思维严谨，整个代码没有特别臃肿的部分。 虽然个人还存在不理解的部分，比如creatstore的设计思想等等。 下面还要继续学习，下一步的阅读计划是react-redux和redux-thunk，希望能趁热打铁把react全家桶的相关代码都阅读学习一遍。","categories":[{"name":"前端","slug":"前端","permalink":"https://github.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"https://github.com/tags/Redux/"}]},{"title":"函数式编程","slug":"函数式编程","date":"2019-02-12T07:50:28.691Z","updated":"2019-11-22T07:06:10.986Z","comments":true,"path":"2019/02/12/函数式编程/","link":"","permalink":"https://github.com/2019/02/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"引言在介绍函数式编程之前，我们先来看下函数在JS中的作用。在JS中，函数是一等公民，除了传统函数的使用，它可以作为普通变量一样作为函数参数，还可以在函数中被返回。除此之外，函数还可以当做类来使用，我们使用new加上函数就可以构造一个实例，并且子类还可以通过构造函数的prototype属性实现原型继承。在React中，组件其实也是一个函数。所以在JS中，函数无处不在。 在软件开发中，我们常见的编程形式有命令式编程和声明式编程。而函数式编程是一种较为抽象的编程方式，是一种强调以函数为主要开发风格的编程方式。在函数式编程中，我们以函数的形式思考和编程。 下面，我们简单来看下命令式编程和声明式编程的区别。 例子1 12345678910// 命令式方式var arr = [0, 1, 2]for(let i = 0; i &lt; array.length; i++) &#123; arr[i] = arr[i] * 2&#125;arr; // [0, 2, 4]// 声明式方式arr.map(num =&gt; num *2) 例子2 123456789// 命令式方式document.getElementById('#root').innerHTML = '&lt;div&gt;根节点&lt;/div&gt;'// 声明式方式function insertMsg(domId, msg, format) &#123; if (!domId) return; document.querySelector(domId).innerHTML = `&lt;$&#123;format&#125;&gt;$&#123;msg&#125;&lt;/$&#123;format&#125;&gt;`&#125;insertMsg('#root','根节点','div') 可以看到，命令式的方式很具体的告诉计算机如何执行某个任务，先做什么再做什么。而声明式的方式主要思想是告诉计算机应该做什么，但不指定具体要怎么做。函数式编程和声明式编程很像，因为他们思想是一致的：即只关注做什么而不是怎么做。但函数式编程不仅仅局限于声明式编程。 总结：这种命令式的写法比较简单，也最容易想到，开发起来很快。缺点显而易见，程序的复用性很差。如果我们有很多类似的这种操作，这就有问题了。函数式编程优点如下。 扩展性：可以通过增加一些额外的代码，而不用修改之前的逻辑来实现功能的扩展 模块化：代码高度解耦，互不影响 重用性：可以相互使用，实现重用 抽象性：隐藏了很多实现的细节 易测试：很容易看出是哪部分代码出了问题 分类高阶函数高阶函数是对其他函数进行操作的函数。满足下列条件之一的函数即可称之为 接受一个或多个函数作为参数 输出一个函数 举例，最常见的是数组内置的一些方法，map和forEach，参数就是一个函数。 高阶函数的优势很明显。下面的例子一目了然。 123456789101112131415// 不使用用高阶函数const arr1 = [1, 2, 3, 4, 5];let arr2 = [];for (let i=0; i&lt;arr1.length; i++) &#123; if (arr1[i]&gt;3) &#123; arr2.push(arr1[i]); &#125;&#125;console.log(arr2); // [4，5]// 使用filterlet arr3 = arr1.filter((ele, index, self) =&gt; &#123; return ele &gt; 3;&#125;);console.log(arr3); 应用一、柯里化(curring) 柯里化又称部分求值。一个柯里化的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数中被真正的需要求值的时候，之前传入的所有参数被一次性用于求值。 柯里化是函数式编程的一个重要技巧，将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。 1234567891011121314151617181920// 用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数function curry(fn) &#123; // 如果传入的函数只有一个参数，直接返回该函数 if (fn.length &lt;= 1) return fn; const generator = (...args) =&gt; &#123; // 判断当前参数长度够不够，参数够了就立马执行 if (fn.length === args.length) &#123; return fn(...args) &#125; else &#123; return (...args2) =&gt; &#123; return generator(...args, ...args2) &#125; &#125; &#125; return generator&#125;let add = (a, b, c, d) =&gt; a + b + c + dconst curryiedAdd = curry(add);curryiedAdd(1)(2)(3)(4) 很多同学知道柯里化的原理，但是不了解它具体在实际编程中的运用。 下面我举几个例子。 例子1，关于网络请求 1234567891011121314151617// 常见的写法function fetch(type,url,data)&#123; let xhr = new XMLHttpRequest(); xhr.open(type, url); xhr.send(data);&#125;// 虽然很通用，但是还是有一些重复代码，而且get和post也不是一眼能区分fetch('get', 'www.test.com', '');fetch('post', 'www.test.com', 'num=10')// 使用currylet fetch = curry(fetch)// 所有post类型的请求都可以使用这个方法let post = fetch('post');// 所有xx接口的post类型的请求都可以使用这个方法let postTest = post('www.test.com');postTest('num=10') 例子2，关于JS类型判断 1234567// 使用对象原型方法toString可以判断几乎所有数据类型let isString = obj =&gt; Object.prototype.toString.call( obj ) === '[object String]';let isRegExp = obj =&gt; Object.prototype.toString.call( obj ) === '[object RegExp]';// 还是一样的的问题，会有很多重复的代码部分，可以抽象出一些重复的部分const isType = type =&gt; target =&gt; `[object $&#123;type&#125;]` === Object.prototype.toString.call(target);const isArray = isType('Array');isArray([]) 例子3，bind的实现 1234567891011121314151617// bind简化实现，原理就是利用柯里化实现延迟计算// 使用es6语法实现起来非常简洁Function.prototype.bind = function (context, ...args) &#123; let fn = this; return (...otherArgs) =&gt; &#123; return fn.apply(context, [...args, ...otherArgs] ); &#125;&#125;let obj = &#123; name: 'abc'&#125;const myfun = function(x, y) &#123; console.log(this.name);&#125;let bindmyfun = myfun.bind(obj);bindmyfun(); 总结：通过上面的例子，我们得出柯里化的主要作用就是延迟计算，参数复用。 二、惰性加载 惰性加载表示函数执行的分支仅会发生一次。举例，如果做PC开发的时候，我们通常需要对不同的浏览器进行事件监听和移除的方法的一个兼容。 下面是正常的写法。 123456789let addEvent = function(ele, type, fn) &#123; if (window.addEventListener) &#123; return ele.addEventListener(type, fn, false); &#125; else if (window.attachEvent) &#123; return ele.attachEvent('on' + type, function() &#123; fn.call(ele); &#125;); &#125;&#125;; 但是，每次在使用这个方法的时候都会执行if else这个判断，其实对于同一个浏览器而言，只需要判断一次环境就可以了。 解决方案1 我们在函数被调用的时候重载函数。 123456789101112131415let addEvent = function(ele, type, fn) &#123; if (window.addEventListener) &#123; addEvent = function(ele, type, fn) &#123; ele.addEventListener(type, fn, false); &#125; &#125; else if (window.attachEvent) &#123; addEvent = function(ele, type, fn) &#123; ele.attachEvent('on' + type, function() &#123; fn.call(ele) &#125;); &#125; &#125; addEvent(ele, type, fn);&#125;; 解决方案2 我们在声明函数时就指定适当函数。这样，第一次调用函数就不会损失性能了，而在代码首次加载时会损失一点性能 12345678910111213let addEvent = (function() &#123; if (window.addEventListener) &#123; return function(ele, type, fn) &#123; ele.addEventListener(type, fn, false); &#125; &#125; else if (window.attachEvent) &#123; addEvent = function(ele, type, fn) &#123; ele.attachEvent('on' + type, function() &#123; fn.call(ele) &#125;); &#125; &#125;&#125;)(); 以上两种方式都只在第一次执行函数时做了性能检测，省去了后续调用时多余的操作，优化了性能。 三、函数节流和防抖 我们都知道在scroll，suggest这样的场景下，函数会被频繁的触发，这样很消耗性能，会造成浏览器的卡顿。 比较好的解决方案就是控制函数被触发的频率，也就是函数节流了。 节流的定义：如果你持续触发事件，每隔一段时间，只执行一次事件。 节流的原理很简单：利用setTimeout和闭包。 关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。 下面介绍的这种方法利用的是定时器的这种形式 12345678910111213// 超级简易版function throttle(func, wait) &#123; let timeout; return function(...args) &#123; let context = this; if (!timeout) &#123; timeout = setTimeout(function()&#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125;&#125; 纯函数纯函数的特征如下。 只依赖于它的参数，同时对于任何相同的输入有着相同的输出结果。 不对外产生副作用 如何理解？ 首先来解释第一点：函数的返回结果只依赖于它的参数 123456789// 非纯函数// 返回结果依赖外部变量a，a的值是不确定的，不能保证相同的输入有相同的结果const a = 1;const fun1 = (b) =&gt; a + b// Math.random()产生一个随机数，所以返回结果也不确定const fun2 = (x) =&gt; Math.random() + x// 纯函数const fun3 = (x) =&gt; x * 2 接下去说一下第二点：副作用是指：在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互。比如说调用 DOM API 修改页面，或者你发送了 Ajax 请求，改变参数或者外部变量的值，还有调用 window.reload刷新浏览器都是副作用的一种表现。 1234567891011121314151617// 非纯函数// 改变了外部变量alet a = &#123; num: 11&#125;;function set(x) &#123; x.num++; return x;&#125;set(a)// 纯函数let a = &#123; num: 11&#125;;function set(x) &#123; let b = &#123;...x&#125;; b.num ++; return b;&#125;set(x) 我们看到纯函数的输出结果是一致的，可预测的，相同的输入会有相同的返回值。 为什么使用纯函数？看下面的例子 1234let num = 0function increment() &#123; return ++num;&#125; 这个函数读取了外部的变量，可能会觉得这段代码没有什么问题，但是我们要知道这种依赖外部变量来进行的计算，计算结果很难预测，你也有可能在其他地方修改了 num 的值，导致你 increment 出来的值不是你预期的，而且你多次调用这个函数返回的结果是不一样的，这样造成的结果就是很难定位到问题发生的原因和位置。 应用最常见的应用就是redux中的reducer。reducer必须是一个纯函数，它会接受一个当前的state和action作为参数，返回一个全新的state，但是不能在原有的state基础上修改。 所以我们常常会见到这样的处理方式 12return Object.assign(&#123;&#125;, state, ...x);return &#123;...state,...x&#125; 那如果我们直接在state上修改，会造成什么结果呢？结果就是页面不会触发重渲染。 所以这就是为什么要求reducer必须是一个纯函数呢，不能修改外部变量。 下面是redux中combineReducers函数的部分源码截图 可以看到在代码中，我们通过对比旧的state对象和新的state对象的地址指针，来决定状态标志位hasChanged是true还是false，从而决定返回的新或旧的state。所以，如果我们直接改变旧state的属性，那preState肯定是等于nextState。 Redux通过对比新旧对象的存储位置是不是一样，来决定state是不是发生了变化。 为什么这样设计呢？答案很简单，性能好。试想一下，如果state层级很深，而我们不是简单的通过preState===nextState来判断state是不是发生变化，那我们唯一的方式就是深对比，通过不断遍历对象，然后通过递归，复杂度可想而知。 总结 可复用性：纯函数仅依赖于传入的参数，这意味着你可以随意将这个函数移植到别的代码中 可测试性：纯函数非常容易进行单元测试，因为不需要考虑上下文环境，只需要考虑输入和输出。 并行代码：纯函数是健壮的，改变执行次序不会对系统造成影响，因此纯函数的操作可以并行执行。 最终目的是：让你的代码尽可能简单易懂和灵活。 函数组合函数组合是一个数学概念，允许你将两个或更多个函数组合到一个新函数中，就像搭积木一样，最后用一个函数实现所有函数的功能。 例如，我们有这样一个需求。输入一个字符串，过滤掉两遍的空格，全部转为大写，重复三遍，最后格式化一下，插入到指定dom中。 于是，我们就开始写代码了 1234567let str = 'angle';function handleStr(x) &#123; x = x.replace(/^(\\s*)|(\\s*)$/g,''); x = new Array(4).join(x); let html = `&lt;h1&gt;i am $&#123;x&#125;&lt;/h1&gt;` document.getElementById('#root').innerHTML = html&#125; 如果有一天，我们还有另外一个业务。不需要过滤空格，格式化为div，重复五遍，最后插入到anotherDom中。于是又写了下面这个函数。 12345function handleStr(x) &#123; x = new Array(6).join(x); let html = `&lt;div&gt;i am $&#123;x&#125;&lt;/div&gt;` document.getElementById('#anotherDom').innerHTML = html&#125; 缺点显而易见了吧。代码冗余，不好理解，很难复用。 所以，如果我们这样写，是不是会优雅很多。 123456789const trim = (x) =&gt; x.replace(/^(\\s*)|(\\s*)$/g,'');const repeat = (n, x) =&gt; new Array(n + 1).join(x);const format = (format, x) =&gt; `&lt;$&#123;format&#125;&gt;i am $&#123;x&#125;&lt;/$&#123;format&#125;&gt;`const insertMsg = (domId, x) =&gt; &#123; if (!domId) return; document.querySelector(domId).innerHTML = x&#125;// 这边需要利用curry函数将多个参数的函数进行柯里化const handleStr = compose(curry(insertMsg)('#root'), curry(format)('h1'), curry(repeat)(3), trim); 那compose函数到底是如何实现的呢 123456789101112131415161718192021222324252627282930313233// 我的实现方式，比较low，但是比较容易看懂function compose(...funcs) &#123; return (...args) =&gt; &#123; let res = funcs[funcs.length-1](...args) for (let i = (funcs.length-2); i&gt;=0; i--) &#123; res = funcs[i](res) &#125; return res; &#125;&#125;// redux的实现function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125;// underscore的实现function compose() &#123; var args = arguments; var start = args.length - 1; return function() &#123; var i = start; var result = args[start].apply(this, arguments); while (i--) result = args[i].call(this, result); return result; &#125;;&#125;; 函数记忆函数记忆是指将上次的计算结果缓存起来，再次调用的时候如果遇到相同的参数，就直接返回缓存中的结果。 比如下面这样 123456let add = (x, y) =&gt; x + y;// 我们实现这样一个函数add = memory(add);add(1,2);// 相同的参数，第二次调用的时候直接从缓存中取出数据，而非重新计算add(1,2) 下面我们来实现以下 12345678910111213const memory = function (fn) &#123; let cache = &#123;&#125;; return function(...args) &#123; // 根据参数生成一个唯一的key，这个key的生成方式还有待研究，不够严谨 let key = args.join('&amp;'); // 如果key命中缓存，说明已经计算过该函数，则直接返回缓存结果 if (cache.hasOwnProperty(key)) &#123; return cache[key] &#125; cache[key] = fn.apply(this, args); return cache[key]; &#125;&#125; 下面测试一下使用效果 1234567891011121314let multiply = (x, y, z) =&gt; x*y*z;let memoryMultiply = memory(multiply);console.time('memory')for (let i=0; i&lt;10000; i++) &#123; memoryMultiply(1,2,3)&#125;console.timeEnd('memory')console.time('not memory')for (let i=0; i&lt;10000; i++) &#123; multiply(1,2,3)&#125;console.timeEnd('not memory') 在chrome控制台运行上面的程序，结果如下，出乎意料的是使用函数记忆居然比不使用要慢了很多。我自己只能理解为，这种简单计算的时间其实比去缓存中存取来得更快。那到底什么场景使用这个呢。我认为是复杂计算或者递归的场景。 我们来看下著名的斐波那契数列。 1234567891011121314151617181920let count = 0;let fibonacci = function(n) &#123; count++; return n &lt; 2? n : fibonacci(n-1) + fibonacci(n-2);&#125;;// 使用普通递归console.time('not memory')fibonacci(20);console.timeEnd('not memory');console.log('计算次数', count)// 使用函数记忆// 注意这边要覆盖自身count = 0;fibonacci = memory(fibonacci);console.time('memory')fibonacci(20);console.timeEnd('memory');console.log('计算次数', count) 可以看到函数真正执行计算的次数和时间大大减少，这就是使用函数记忆的优势了。 总结：函数记忆只是一种编程技巧，memory函数本质上它也属于一种高阶函数。从上面的例子看得出来，并不是所有场景都适用于这种方式。而且这种方式还有一个缺点是牺牲算法的空间复杂度。所以，最适合业务场景的才是最好的。 函数式编程的使用函数式编程的最典型应用就是Redux。 下面我们一起来看下源码的解析。 redux源码浅读","categories":[{"name":"前端","slug":"前端","permalink":"https://github.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://github.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}]}