<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>函数式编程 | Hexo</title>
  <meta name="description" content="引言在介绍函数式编程之前，我们先来看下函数在JS中的作用。在JS中，函数是一等公民，除了传统函数的使用，它可以作为普通变量一样作为函数参数，还可以在函数中被返回。除此之外，函数还可以当做类来使用，我们使用new加上函数就可以构造一个实例，并且子类还可以通过构造函数的prototype属性实现原型继承。在React中，组件其实也是一个函数。所以在JS中，函数无处不在。 在软件开发中，我们常见的编程形">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="函数式编程">
<meta property="og:url" content="https:&#x2F;&#x2F;only-twj520q.github.io&#x2F;2019&#x2F;02&#x2F;12&#x2F;%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&#x2F;index.html">
<meta property="og:site_name" content="twj的个人小站">
<meta property="og:description" content="引言在介绍函数式编程之前，我们先来看下函数在JS中的作用。在JS中，函数是一等公民，除了传统函数的使用，它可以作为普通变量一样作为函数参数，还可以在函数中被返回。除此之外，函数还可以当做类来使用，我们使用new加上函数就可以构造一个实例，并且子类还可以通过构造函数的prototype属性实现原型继承。在React中，组件其实也是一个函数。所以在JS中，函数无处不在。 在软件开发中，我们常见的编程形">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;ws3.sinaimg.cn&#x2F;large&#x2F;006tNc79ly1g3qk04gcxdj30h50920u3.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;ws4.sinaimg.cn&#x2F;large&#x2F;006tNc79ly1g3rjue5wrzj30e6078mxn.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;ws1.sinaimg.cn&#x2F;large&#x2F;006tNc79ly1g3rk9ysp2aj30iu09e3zh.jpg">
<meta property="og:updated_time" content="2019-11-22T07:06:10.986Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;ws3.sinaimg.cn&#x2F;large&#x2F;006tNc79ly1g3qk04gcxdj30h50920u3.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://only-twj520q.github.io/2019/02/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/index.html">
  
    <link rel="alternate" href="/atom.xml" title="twj的个人小站" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/only-twj520Q.github.io/css/style.css">
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitment@0.0.3/style/default.min.css">
  
  
  
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/only-twj520Q" target="_blank">
          <img class="img-circle img-rotate" src="/only-twj520Q.github.io/images/avatar.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Sunny_杰少</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">一枚帝都程序猿</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Beijing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/only-twj520Q.github.io/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/only-twj520Q.github.io/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/only-twj520Q.github.io/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/only-twj520Q.github.io/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/only-twj520Q.github.io/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/only-twj520Q.github.io/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/only-twj520Q.github.io/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/only-twj520Q.github.io/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/only-twj520Q" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/u/6356069422" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://www.facebook.com/profile.php?id=100041542582495" target="_blank" title="Facebook" data-toggle=tooltip data-placement=top><i class="icon icon-facebook"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/only-twj520Q.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">8</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/only-twj520Q.github.io/tags/JavaScript/" rel="tag">JavaScript</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/only-twj520Q.github.io/tags/Redux/" rel="tag">Redux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/only-twj520Q.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/only-twj520Q.github.io/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/" rel="tag">打包构建</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/only-twj520Q.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/only-twj520Q.github.io/tags/JavaScript/" style="font-size: 14px;">JavaScript</a> <a href="/only-twj520Q.github.io/tags/Redux/" style="font-size: 13px;">Redux</a> <a href="/only-twj520Q.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 13px;">性能优化</a> <a href="/only-twj520Q.github.io/tags/%E6%89%93%E5%8C%85%E6%9E%84%E5%BB%BA/" style="font-size: 13px;">打包构建</a> <a href="/only-twj520Q.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13px;">设计模式</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/only-twj520Q.github.io/archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/only-twj520Q.github.io/archives/2019/03/">三月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/only-twj520Q.github.io/archives/2019/02/">二月 2019</a><span class="archive-list-count">5</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/only-twj520Q.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</a>
              </p>
              <p class="item-title">
                <a href="/only-twj520Q.github.io/2019/11/08/%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84babel/" class="title">我理解的babel</a>
              </p>
              <p class="item-date">
                <time datetime="2019-11-08T07:12:55.975Z" itemprop="datePublished">2019-11-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/only-twj520Q.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</a>
              </p>
              <p class="item-title">
                <a href="/only-twj520Q.github.io/2019/03/24/%E5%BC%82%E6%AD%A5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" class="title">异步错误的获取</a>
              </p>
              <p class="item-date">
                <time datetime="2019-03-24T05:47:16.101Z" itemprop="datePublished">2019-03-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/only-twj520Q.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</a>
              </p>
              <p class="item-title">
                <a href="/only-twj520Q.github.io/2019/03/09/Promise%E6%9D%82%E8%B0%88/" class="title">Promise杂谈</a>
              </p>
              <p class="item-date">
                <time datetime="2019-03-09T05:34:08.260Z" itemprop="datePublished">2019-03-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/only-twj520Q.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</a>
              </p>
              <p class="item-title">
                <a href="/only-twj520Q.github.io/2019/02/12/canvas%E5%92%8Cimg%E6%97%A5%E5%B8%B8%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C/" class="title">canvas和img日常转换操作</a>
              </p>
              <p class="item-date">
                <time datetime="2019-02-12T07:50:28.691Z" itemprop="datePublished">2019-02-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/only-twj520Q.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</a>
              </p>
              <p class="item-title">
                <a href="/only-twj520Q.github.io/2019/02/12/%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%A4%A7%E5%B0%8F%E5%B1%9E%E6%80%A7/" class="title">容易混淆的元素位置和大小属性</a>
              </p>
              <p class="item-date">
                <time datetime="2019-02-12T07:50:28.691Z" itemprop="datePublished">2019-02-12</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-函数式编程" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      函数式编程
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/only-twj520Q.github.io/2019/02/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="article-date">
	  <time datetime="2019-02-12T07:50:28.691Z" itemprop="datePublished">2019-02-12</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/only-twj520Q.github.io/categories/%E5%89%8D%E7%AB%AF/">前端</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/only-twj520Q.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/only-twj520Q.github.io/2019/02/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 4.2k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 17(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在介绍函数式编程之前，我们先来看下函数在JS中的作用。在JS中，函数是一等公民，除了传统函数的使用，它可以作为普通变量一样作为函数参数，还可以在函数中被返回。除此之外，函数还可以当做类来使用，我们使用new加上函数就可以构造一个实例，并且子类还可以通过构造函数的prototype属性实现原型继承。在React中，组件其实也是一个函数。所以在JS中，函数无处不在。</p>
<p>在软件开发中，我们常见的编程形式有命令式编程和声明式编程。而函数式编程是一种较为抽象的编程方式，是一种强调以函数为主要开发风格的编程方式。在函数式编程中，我们以函数的形式思考和编程。</p>
<p>下面，我们简单来看下命令式编程和声明式编程的区别。</p>
<ul>
<li>例子1</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式方式</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">  arr[i] = arr[i] * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr; <span class="comment">// [0, 2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式方式</span></span><br><span class="line">arr.map(<span class="function"><span class="params">num</span> =&gt;</span> num *<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>例子2</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式方式</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'#root'</span>).innerHTML = <span class="string">'&lt;div&gt;根节点&lt;/div&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertMsg</span>(<span class="params">domId, msg, format</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!domId) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(domId).innerHTML = <span class="string">`&lt;<span class="subst">$&#123;format&#125;</span>&gt;<span class="subst">$&#123;msg&#125;</span>&lt;/<span class="subst">$&#123;format&#125;</span>&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line">insertMsg(<span class="string">'#root'</span>,<span class="string">'根节点'</span>,<span class="string">'div'</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，命令式的方式很具体的告诉计算机如何执行某个任务，先做什么再做什么。而声明式的方式主要思想是告诉计算机应该做什么，但不指定具体要怎么做。函数式编程和声明式编程很像，因为他们思想是一致的：即只关注做什么而不是怎么做。但函数式编程不仅仅局限于声明式编程。</p>
<p><strong>总结：</strong>这种命令式的写法比较简单，也最容易想到，开发起来很快。缺点显而易见，程序的复用性很差。如果我们有很多类似的这种操作，这就有问题了。函数式编程优点如下。</p>
<ul>
<li><p>扩展性：可以通过增加一些额外的代码，而不用修改之前的逻辑来实现功能的扩展</p>
</li>
<li><p>模块化：代码高度解耦，互不影响</p>
</li>
<li><p>重用性：可以相互使用，实现重用</p>
</li>
<li><p>抽象性：隐藏了很多实现的细节</p>
</li>
<li><p>易测试：很容易看出是哪部分代码出了问题</p>
</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数是对其他函数进行操作的函数。满足下列条件之一的函数即可称之为</p>
<ul>
<li>接受一个或多个函数作为参数</li>
<li>输出一个函数</li>
</ul>
<p>举例，最常见的是数组内置的一些方法，map和forEach，参数就是一个函数。</p>
<p>高阶函数的优势很明显。下面的例子一目了然。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用用高阶函数</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr1.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr1[i]&gt;<span class="number">3</span>) &#123;</span><br><span class="line">    arr2.push(arr1[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr2);  <span class="comment">// [4，5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用filter</span></span><br><span class="line"><span class="keyword">let</span> arr3 = arr1.filter(<span class="function">(<span class="params">ele, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ele &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><strong>一、柯里化(curring)</strong></p>
<p>柯里化又称部分求值。一个柯里化的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数中被真正的需要求值的时候，之前传入的所有参数被一次性用于求值。</p>
<p>柯里化是函数式编程的一个重要技巧，将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果传入的函数只有一个参数，直接返回该函数</span></span><br><span class="line">  <span class="keyword">if</span> (fn.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> fn;</span><br><span class="line">  <span class="keyword">const</span> generator = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前参数长度够不够，参数够了就立马执行</span></span><br><span class="line">    <span class="keyword">if</span> (fn.length === args.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn(...args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generator(...args, ...args2)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> generator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> a + b + c + d</span><br><span class="line"><span class="keyword">const</span> curryiedAdd = curry(add);</span><br><span class="line">curryiedAdd(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>很多同学知道柯里化的原理，但是不了解它具体在实际编程中的运用。</p>
<p>下面我举几个例子。</p>
<ul>
<li>例子1，关于网络请求</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">type,url,data</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(type, url);</span><br><span class="line">  xhr.send(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虽然很通用，但是还是有一些重复代码，而且get和post也不是一眼能区分</span></span><br><span class="line">fetch(<span class="string">'get'</span>, <span class="string">'www.test.com'</span>, <span class="string">''</span>);</span><br><span class="line">fetch(<span class="string">'post'</span>, <span class="string">'www.test.com'</span>, <span class="string">'num=10'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用curry</span></span><br><span class="line"><span class="keyword">let</span> fetch = curry(fetch)</span><br><span class="line"><span class="comment">// 所有post类型的请求都可以使用这个方法</span></span><br><span class="line"><span class="keyword">let</span> post = fetch(<span class="string">'post'</span>);</span><br><span class="line"><span class="comment">// 所有xx接口的post类型的请求都可以使用这个方法</span></span><br><span class="line"><span class="keyword">let</span> postTest = post(<span class="string">'www.test.com'</span>);</span><br><span class="line">postTest(<span class="string">'num=10'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>例子2，关于JS类型判断</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用对象原型方法toString可以判断几乎所有数据类型</span></span><br><span class="line"><span class="keyword">let</span> isString = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object String]'</span>;</span><br><span class="line"><span class="keyword">let</span> isRegExp = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call( obj ) === <span class="string">'[object RegExp]'</span>;</span><br><span class="line"><span class="comment">// 还是一样的的问题，会有很多重复的代码部分，可以抽象出一些重复的部分</span></span><br><span class="line"><span class="keyword">const</span> isType = <span class="function"><span class="params">type</span> =&gt;</span> <span class="function"><span class="params">target</span> =&gt;</span> <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span> === <span class="built_in">Object</span>.prototype.toString.call(target);</span><br><span class="line"><span class="keyword">const</span> isArray = isType(<span class="string">'Array'</span>);</span><br><span class="line">isArray([])</span><br></pre></td></tr></table></figure>

<ul>
<li>例子3，bind的实现</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind简化实现，原理就是利用柯里化实现延迟计算</span></span><br><span class="line"><span class="comment">// 使用es6语法实现起来非常简洁</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...otherArgs</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context, [...args, ...otherArgs] );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'abc'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myfun = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bindmyfun = myfun.bind(obj);</span><br><span class="line">bindmyfun();</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>通过上面的例子，我们得出柯里化的主要作用就是延迟计算，参数复用。</p>
<p><strong>二、惰性加载</strong></p>
<p>惰性加载表示函数执行的分支仅会发生一次。举例，如果做PC开发的时候，我们通常需要对不同的浏览器进行事件监听和移除的方法的一个兼容。</p>
<p>下面是正常的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">ele, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    <span class="keyword">return</span> ele.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">    <span class="keyword">return</span> ele.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.call(ele);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是，每次在使用这个方法的时候都会执行if else这个判断，其实对于同一个浏览器而言，只需要判断一次环境就可以了。</p>
<ul>
<li>解决方案1</li>
</ul>
<p>我们在函数被调用的时候重载函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">ele, type, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">ele, type, fn</span>) </span>&#123;</span><br><span class="line">      ele.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">    addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">ele, type, fn</span>) </span>&#123;</span><br><span class="line">      ele.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fn.call(ele)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addEvent(ele, type, fn);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案2</li>
</ul>
<p>我们在声明函数时就指定适当函数。这样，第一次调用函数就不会损失性能了，而在代码首次加载时会损失一点性能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">ele, type, fn</span>) </span>&#123;</span><br><span class="line">      ele.addEventListener(type, fn, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">    addEvent = <span class="function"><span class="keyword">function</span>(<span class="params">ele, type, fn</span>) </span>&#123;</span><br><span class="line">      ele.attachEvent(<span class="string">'on'</span> + type, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        fn.call(ele)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>以上两种方式都只在第一次执行函数时做了性能检测，省去了后续调用时多余的操作，优化了性能。</p>
<p><strong>三、函数节流和防抖</strong></p>
<p>我们都知道在scroll，suggest这样的场景下，函数会被频繁的触发，这样很消耗性能，会造成浏览器的卡顿。</p>
<p>比较好的解决方案就是控制函数被触发的频率，也就是函数节流了。</p>
<p>节流的定义：如果你持续触发事件，每隔一段时间，只执行一次事件。</p>
<p>节流的原理很简单：利用setTimeout和闭包。</p>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<p>下面介绍的这种方法利用的是定时器的这种形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超级简易版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        func.apply(context, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>纯函数的特征如下。</p>
<ul>
<li>只依赖于它的参数，同时对于任何相同的输入有着相同的输出结果。</li>
</ul>
<ul>
<li>不对外产生副作用</li>
</ul>
<p>如何理解？</p>
<p>首先来解释第一点：<strong>函数的返回结果只依赖于它的参数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非纯函数</span></span><br><span class="line"><span class="comment">// 返回结果依赖外部变量a，a的值是不确定的，不能保证相同的输入有相同的结果</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> fun1 = <span class="function">(<span class="params">b</span>) =&gt;</span> a + b</span><br><span class="line"><span class="comment">// Math.random()产生一个随机数，所以返回结果也不确定</span></span><br><span class="line"><span class="keyword">const</span> fun2 = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">Math</span>.random() + x</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯函数</span></span><br><span class="line"><span class="keyword">const</span> fun3 = <span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>接下去说一下第二点：副作用是指：<strong>在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互</strong>。比如说调用 DOM API 修改页面，或者你发送了 Ajax 请求，改变参数或者外部变量的值，还有调用 <code>window.reload</code>刷新浏览器都是副作用的一种表现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非纯函数</span></span><br><span class="line"><span class="comment">// 改变了外部变量a</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">num</span>: <span class="number">11</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> x.num++;</span><br><span class="line"> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span>(a)</span><br><span class="line"></span><br><span class="line">// 纯函数</span><br><span class="line">let a = &#123; num: <span class="number">11</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> b = &#123;...x&#125;;</span><br><span class="line"> b.num ++;</span><br><span class="line"> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span>(x)</span><br></pre></td></tr></table></figure>

<p>我们看到纯函数的输出结果是一致的，可预测的，相同的输入会有相同的返回值。</p>
<p>为什么使用纯函数？看下面的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个函数读取了外部的变量，可能会觉得这段代码没有什么问题，但是我们要知道这种依赖外部变量来进行的计算，计算结果很难预测，你也有可能在其他地方修改了 num 的值，导致你 increment 出来的值不是你预期的，而且你多次调用这个函数返回的结果是不一样的，这样造成的结果就是很难定位到问题发生的原因和位置。</p>
<h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><p>最常见的应用就是<code>redux</code>中的reducer。reducer必须是一个纯函数，它会接受一个当前的state和action作为参数，返回一个全新的state，但是不能在原有的state基础上修改。</p>
<p>所以我们常常会见到这样的处理方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, ...x);</span><br><span class="line"><span class="keyword">return</span> &#123;...state,...x&#125;</span><br></pre></td></tr></table></figure>

<p>那如果我们直接在state上修改，会造成什么结果呢？结果就是页面不会触发重渲染。</p>
<p>所以这就是为什么要求reducer必须是一个纯函数呢，不能修改外部变量。</p>
<p>下面是redux中<strong>combineReducers</strong>函数的部分源码截图</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g3qk04gcxdj30h50920u3.jpg" alt=""></p>
<p>可以看到在代码中，我们通过对比旧的state对象和新的state对象的地址指针，来决定状态标志位hasChanged是true还是false，从而决定返回的新或旧的state。所以，如果我们直接改变旧state的属性，那preState肯定是等于nextState。</p>
<p>Redux通过对比新旧对象的存储位置是不是一样，来决定state是不是发生了变化。</p>
<p>为什么这样设计呢？答案很简单，性能好。试想一下，如果state层级很深，而我们不是简单的通过<code>preState===nextState</code>来判断state是不是发生变化，那我们唯一的方式就是深对比，通过不断遍历对象，然后通过递归，复杂度可想而知。</p>
<p><strong>总结</strong></p>
<ul>
<li><p>可复用性：纯函数仅依赖于传入的参数，这意味着你可以随意将这个函数移植到别的代码中</p>
</li>
<li><p>可测试性：纯函数非常容易进行单元测试，因为不需要考虑上下文环境，只需要考虑输入和输出。</p>
</li>
<li><p>并行代码：纯函数是健壮的，改变执行次序不会对系统造成影响，因此纯函数的操作可以并行执行。</p>
</li>
</ul>
<p>最终目的是：<strong>让你的代码尽可能简单易懂和灵活</strong>。</p>
<h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><p>函数组合是一个数学概念，允许你将两个或更多个函数组合到一个新函数中，就像搭积木一样，最后用一个函数实现所有函数的功能。</p>
<p>例如，我们有这样一个需求。输入一个字符串，过滤掉两遍的空格，全部转为大写，重复三遍，最后格式化一下，插入到指定dom中。</p>
<p>于是，我们就开始写代码了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'angle'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStr</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = x.replace(<span class="regexp">/^(\s*)|(\s*)$/g</span>,<span class="string">''</span>);</span><br><span class="line">  x = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>).join(x);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="string">`&lt;h1&gt;i am <span class="subst">$&#123;x&#125;</span>&lt;/h1&gt;`</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'#root'</span>).innerHTML = html</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果有一天，我们还有另外一个业务。不需要过滤空格，格式化为div，重复五遍，最后插入到anotherDom中。于是又写了下面这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleStr</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>).join(x);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="string">`&lt;div&gt;i am <span class="subst">$&#123;x&#125;</span>&lt;/div&gt;`</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'#anotherDom'</span>).innerHTML = html</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点显而易见了吧。代码冗余，不好理解，很难复用。</p>
<p>所以，如果我们这样写，是不是会优雅很多。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> trim = <span class="function">(<span class="params">x</span>) =&gt;</span> x.replace(<span class="regexp">/^(\s*)|(\s*)$/g</span>,<span class="string">''</span>);</span><br><span class="line"><span class="keyword">const</span> repeat = <span class="function">(<span class="params">n, x</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).join(x);</span><br><span class="line"><span class="keyword">const</span> format = <span class="function">(<span class="params">format, x</span>) =&gt;</span> <span class="string">`&lt;<span class="subst">$&#123;format&#125;</span>&gt;i am <span class="subst">$&#123;x&#125;</span>&lt;/<span class="subst">$&#123;format&#125;</span>&gt;`</span></span><br><span class="line"><span class="keyword">const</span> insertMsg = <span class="function">(<span class="params">domId, x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!domId) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(domId).innerHTML = x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这边需要利用curry函数将多个参数的函数进行柯里化</span></span><br><span class="line"><span class="keyword">const</span> handleStr = compose(curry(insertMsg)(<span class="string">'#root'</span>), curry(format)(<span class="string">'h1'</span>), curry(repeat)(<span class="number">3</span>), trim);</span><br></pre></td></tr></table></figure>

<p>那compose函数到底是如何实现的呢</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我的实现方式，比较low，但是比较容易看懂</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = funcs[funcs.length<span class="number">-1</span>](...args)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = (funcs.length<span class="number">-2</span>); i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">      res = funcs[i](res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// redux的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// underscore的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">var</span> start = args.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = start;</span><br><span class="line">    <span class="keyword">var</span> result = args[start].apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">while</span> (i--) result = args[i].call(<span class="keyword">this</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="函数记忆"><a href="#函数记忆" class="headerlink" title="函数记忆"></a>函数记忆</h2><p>函数记忆是指将上次的计算结果缓存起来，再次调用的时候如果遇到相同的参数，就直接返回缓存中的结果。</p>
<p>比如下面这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="comment">// 我们实现这样一个函数</span></span><br><span class="line">add = memory(add);</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 相同的参数，第二次调用的时候直接从缓存中取出数据，而非重新计算</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>下面我们来实现以下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memory = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> cache = &#123;&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据参数生成一个唯一的key，这个key的生成方式还有待研究，不够严谨</span></span><br><span class="line">    <span class="keyword">let</span> key = args.join(<span class="string">'&amp;'</span>);</span><br><span class="line">    <span class="comment">// 如果key命中缓存，说明已经计算过该函数，则直接返回缓存结果</span></span><br><span class="line">    <span class="keyword">if</span> (cache.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[key]</span><br><span class="line">    &#125;</span><br><span class="line">    cache[key] = fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">	 	<span class="keyword">return</span> cache[key];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面测试一下使用效果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> multiply = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> x*y*z;</span><br><span class="line"><span class="keyword">let</span> memoryMultiply = memory(multiply);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'memory'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">  memoryMultiply(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'memory'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'not memory'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">  multiply(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'not memory'</span>)</span><br></pre></td></tr></table></figure>

<p>在chrome控制台运行上面的程序，结果如下，出乎意料的是使用函数记忆居然比不使用要慢了很多。我自己只能理解为，这种简单计算的时间其实比去缓存中存取来得更快。那到底什么场景使用这个呢。我认为是复杂计算或者递归的场景。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g3rjue5wrzj30e6078mxn.jpg" alt=""></p>
<p>我们来看下著名的斐波那契数列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> fibonacci = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  	count++;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">2</span>? n : fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用普通递归</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'not memory'</span>)</span><br><span class="line">fibonacci(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'not memory'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'计算次数'</span>, count)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数记忆</span></span><br><span class="line"><span class="comment">// 注意这边要覆盖自身</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">fibonacci = memory(fibonacci);</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'memory'</span>)</span><br><span class="line">fibonacci(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'memory'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'计算次数'</span>, count)</span><br></pre></td></tr></table></figure>

<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g3rk9ysp2aj30iu09e3zh.jpg" alt=""></p>
<p>可以看到函数真正执行计算的次数和时间大大减少，这就是使用函数记忆的优势了。</p>
<p><strong>总结：</strong>函数记忆只是一种编程技巧，memory函数本质上它也属于一种高阶函数。从上面的例子看得出来，并不是所有场景都适用于这种方式。而且这种方式还有一个缺点是牺牲算法的空间复杂度。所以，最适合业务场景的才是最好的。</p>
<h2 id="函数式编程的使用"><a href="#函数式编程的使用" class="headerlink" title="函数式编程的使用"></a>函数式编程的使用</h2><p>函数式编程的最典型应用就是Redux。</p>
<p>下面我们一起来看下源码的解析。</p>
<p><a href="https://github.com/only-twj520Q/Blog/blob/master/redux源码浅读.md" target="_blank" rel="noopener"><strong>redux源码浅读</strong></a></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://only-twj520q.github.io/2019/02/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" title="函数式编程" target="_blank" rel="external">https://only-twj520q.github.io/2019/02/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/only-twj520Q" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/only-twj520Q.github.io/images/avatar.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/only-twj520Q" target="_blank"><span class="text-dark">Sunny_杰少</span><small class="ml-1x">一枚帝都程序猿</small></a></h3>
        <div>喜欢唱，不喜欢跳，喜欢篮球，但不喜欢rap的宅男</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	

    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/only-twj520Q.github.io/2019/02/12/%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E5%92%8C%E5%A4%A7%E5%B0%8F%E5%B1%9E%E6%80%A7/" title="容易混淆的元素位置和大小属性"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/only-twj520Q.github.io/2019/02/12/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/" title="前端性能监控"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/only-twj520Q.github.io/images/donate/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/only-twj520Q.github.io/images/donate/wechatpayimg.jpg" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/only-twj520Q" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/u/6356069422" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://www.facebook.com/profile.php?id=100041542582495" target="_blank" title="Facebook" data-toggle=tooltip data-placement=top><i class="icon icon-facebook"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/only-twj520Q.github.io/js/plugin.min.js"></script>
<script src="/only-twj520Q.github.io/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/only-twj520Q.github.io/',
        CONTENT_URL: '/only-twj520Q.github.io/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/only-twj520Q.github.io/js/insight.js"></script>





   




   
    
<script src="//cdn.jsdelivr.net/npm/gitment@0.0.3/dist/gitment.browser.min.js"></script>
<script>
var gitment = new Gitment({
  // id默认为当前页面url，如果url后带参数或锚点，gitment要重新初始化
  // https://github.com/imsun/gitment/issues/55
  // 解决方案：id:window.location.pathname,或者将id设置为当前页面标题
  id: '函数式编程', 
  owner: '32264536', // 可以是你的GitHub用户名，也可以是github id
  repo: '',
  oauth: {
    client_id: '',
    client_secret: '',
  }
})
gitment.render('comments')
</script>









</body>
</html>